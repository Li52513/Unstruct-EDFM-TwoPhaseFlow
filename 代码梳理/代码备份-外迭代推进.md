```C++
// ============ 一次外迭代：CO2相 ============
inline bool doOneOuter_CO2
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	const RockDefaults& rock,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dp_inf,
	double& dT_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	// 1) k层初值 -> 工作场
	if (!startOuterIteration(reg, "p_g", "T", "p_g_prev", "T_prev")) return false;

	// 2) 构建 θ-评估点（只控制一次，干净）
	const double theta_p = std::min(1.0, std::max(0.0, ctrl.theta_p));
	const double theta_T = std::min(1.0, std::max(0.0, ctrl.theta_T));
	buildEvalFields(
		reg,
		/*p_old*/ "p_g_old", /*p_iter*/ "p_g",
		/*T_old*/ "T_old",   /*T_iter*/ "T",
		/*p_eval*/ "p_eval", /*T_eval*/ "T_eval",
		theta_p, theta_T
	);

	// 3) 物性在“评估场”处评估（一次性）
	ppm.UpdateMatrixRockAt(mgr, reg, "p_eval", "T_eval");
	ppm.UpdateMatrixFluidAt(mgr, reg, "p_eval", "T_eval", "CO2");
	ppm.ComputeMatrixEffectiveThermalsAt(mgr, reg, "p_eval", "T_eval", "CO2", 1e-12);

	// —— 压力时间项需要：rho_eval 与 drho_dp_eval（评估点），以及 rho_old（旧层） ——
	// 3.1 评估点的 rho 和 drho/dp
	computeRhoAndDrhoDpAt(
		mgr, reg,
		/*p_name*/ "p_eval",
		/*T_name*/ "T_eval",
		/*phase*/  "CO2",
		/*rho_out*/     "rho_eval",
		/*drhodp_out*/  "drho_dp_eval"
	);
	// 3.2 旧层密度（若你已有 computeRhoAt 就用它；没有的话用 AndDrhoDp 退而求其次）
	// computeRhoAt(mgr, reg, "p_g_old", "T_old", "CO2", "rho_old");
	{
		// 临时：再算一次，导数丢掉即可
		computeRhoAndDrhoDpAt(
			mgr, reg,
			/*p_name*/ "p_g_old",
			/*T_name*/ "T_old",
			/*phase*/  "CO2",
			/*rho_out*/     "rho_old",
			/*drhodp_out*/  "_junk_drdp_old"
		);
	}

	// 4) 压力：扩散 + （θ-版）时间项 + 组装 + 解
	SparseSystemCOO sysP;
	{
		DiffusionIterm_TPFA_CO2_singlePhase_DarcyFlow
		(
			mgr, reg, freg, gu, rock.k_iso, Pbc,
			/*a_name*/ "a_f_Diff_p_g",
			/*s_name*/ "s_f_Diff_p_g",
			/*x_name*/ "p_g",
			/*enable_buoy*/ true,
			/*gradSmoothIters*/ 1
		);

		// θ-评估统一版时间项（与温度风格一致）
		TimeTerm_Theta_SinglePhase_Flow
		(
			mgr, reg, dt, ctrl.c_phi_const,
			/*phi_name*/        "phi",
			/*p_old_name*/      "p_g_old",
			/*rho_old_name*/    "rho_old",
			/*p_eval_name*/     "p_eval",
			/*T_eval_name*/     "T_eval",
			/*rho_eval_name*/   "rho_eval",
			/*drdp_eval_name*/  "drho_dp_eval",
			/*aC_name*/         "aC_time_p",
			/*bC_name*/         "bC_time_p"
		);

		assemblePressure_CO2_singlePhase_COO(mgr, reg, freg, &sysP);
		
		const bool needCompressP =
			(ctrl.lin_p.type == LinearSolverOptions::Type::SparseLU) ||
			(ctrl.lin_p.type == LinearSolverOptions::Type::LDLT) ||
			(lastSysP != nullptr);
		
		if (needCompressP) sysP.compressInPlace(0.0);

		if (ctrl.reportPerIter)
		{
			auto R = PostChecks::reportAssembly(sysP, false);
			PostChecks::printAssemblyReport(R, "P(CO2)");
		}

		int N = 0; auto lid = buildUnknownMap(mesh, N);
		auto p_vec = gatherFieldToVec(reg, mesh, "p_g", lid, N);
		double resP = 0; int itP = 0; bool okP = false;

		if (!ctrl.useJacobi) {
			auto opt = ctrl.lin_p; if (opt.tol <= 0.0) opt.tol = ctrl.tol_p_abs;
			okP = solveCOO_Eigen(sysP, p_vec, opt, &itP, &resP);
			if (!okP) std::cerr << "[LinearSolver] pressure failed, fallback Jacobi.\n";
		}
		if (ctrl.useJacobi || !okP) {
			jacobiSolve(sysP, p_vec, ctrl.jac_p, &resP, &itP);
		}
		scatterVecToField(reg, mesh, "p_g", lid, p_vec);
	}

	// 5) 温度：扩散 + 对流 + （θ-版）时间项 + 解
	SparseSystemCOO sysT;
	{
		DiffusionIterm_TPFA_Temperature_singlePhase(
			mgr, reg, freg, gu,
			/*lambda_eff*/ "lambda_eff",
			Tbc,
			/*a_f*/ "a_f_Diff_T",
			/*s_f*/ "s_f_Diff_T",
			/*T_field*/ "T"
		);

		Convective_FirstOrder_SinglePhase_Temperature(
			mgr, reg, freg, Tbc,
			/*cp*/ "cp_g",
			/*p*/  "p_g",
			/*T*/  "T",
			/*a_f^p*/ "a_f_Diff_p_g",
			/*s_f^p*/ "s_f_Diff_p_g",
			/*aPP*/ "aPP_conv",
			/*aPN*/ "aPN_conv",
			/*bP*/  "bP_conv"
		);

		// θ-评估统一版温度时间项
		// 此时 rho_r/cp_r/rho_g/cp_g 已由 ppm 在 (p_eval,T_eval) 处更新到字段里
		TimeTerm_Theta_SinglePhase_Temperature
		(
			mgr, reg, dt,
			/*Ceff_floor*/ 1e-12,
			/*phi_name*/   "phi",
			/*rho_r_name*/ "rho_r",
			/*cp_r_name*/  "cp_r",
			/*rho_f_name*/ "rho_g",
			/*cp_f_name*/  "cp_g",
			/*T_old_name*/ "T_old",
			/*aC_name*/    "aC_time_T",
			/*bC_name*/    "bC_time_T",
			/*Ceff_out*/   "Ceff_T"  // 可选诊断输出
		);

		assembleTemperature_singlePhase_COO(
			mgr, reg, freg,
			"a_f_Diff_T", "s_f_Diff_T",
			"aPP_conv", "aPN_conv", "bP_conv",
			"aC_time_T", "bC_time_T",
			&sysT
		);
		const bool needCompressT =
			(ctrl.lin_T.type == LinearSolverOptions::Type::SparseLU) ||
			(ctrl.lin_T.type == LinearSolverOptions::Type::LDLT) ||
			(lastSysT != nullptr);
		if (needCompressT) sysT.compressInPlace(0.0);

		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysT, false);
			PostChecks::printAssemblyReport(R, "T(CO2)");
		}

		int N = 0; auto lid = buildUnknownMap(mesh, N);
		auto T_vec = gatherFieldToVec(reg, mesh, "T", lid, N);
		double resT = 0; int itT = 0; bool okT = false;

		if (!ctrl.useJacobi) {
			auto opt = ctrl.lin_T; if (opt.tol <= 0.0) opt.tol = ctrl.tol_T_abs;
			okT = solveCOO_Eigen(sysT, T_vec, opt, &itT, &resT);
			if (!okT) std::cerr << "[LinearSolver] temperature failed, fallback Jacobi.\n";
		}
		if (ctrl.useJacobi || !okT) {
			jacobiSolve(sysT, T_vec, ctrl.jac_T, &resT, &itT);
		}
		scatterVecToField(reg, mesh, "T", lid, T_vec);

		// 可选：温度限幅（若仍想保留）
		//if (auto Tfield = reg.get<volScalarField>("T")) {
		//	for (double& val : Tfield->data) {
		//		if (val < 373.15)      val = 373.15;
		//		else if (val > 450.0)  val = 450.0;
		//	}
		//}
	}

	// 6) 欠松弛 + 收敛衡量
	underRelaxInPlace(reg, "p_g", "p_g_prev", ctrl.urf_p);
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);

	dp_inf = maxAbsDiff(reg, "p_g", "p_g_prev");
	dT_inf = maxAbsDiff(reg, "T", "T_prev");

	updatePrevIterates(reg, "p_g", "T", "p_g_prev", "T_prev");

	if (lastSysP) *lastSysP = sysP;
	if (lastSysT) *lastSysT = sysT;
	return true;
}

// ============ 一次外迭代：WATER ============
inline bool doOneOuter_WATER
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	const RockDefaults& rock,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dp_inf,
	double& dT_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	// 1) k层初值 -> 工作场
	if (!startOuterIteration(reg, "p_w", "T", "p_w_prev", "T_prev")) return false;

	// 2) 构建 θ-评估点（只控制一次，干净）
	const double theta_p = std::min(1.0, std::max(0.0, ctrl.theta_p));
	const double theta_T = std::min(1.0, std::max(0.0, ctrl.theta_T));
	buildEvalFields(
		reg,
		/*p_old*/ "p_w_old", /*p_iter*/ "p_w",
		/*T_old*/ "T_old",   /*T_iter*/ "T",
		/*p_eval*/ "p_eval", /*T_eval*/ "T_eval",
		theta_p, theta_T
	);

	// 3) 物性在“评估场”处评估（一次性）
	ppm.UpdateMatrixRockAt(mgr, reg, "p_eval", "T_eval");
	ppm.UpdateMatrixFluidAt(mgr, reg, "p_eval", "T_eval", "water");
	ppm.ComputeMatrixEffectiveThermalsAt(mgr, reg, "p_eval", "T_eval", "water", 1e-12);

	// —— 压力时间项需要：rho_eval 与 drho_dp_eval（评估点），以及 rho_old（旧层） ——
	// 3.1 评估点的 rho 和 drho/dp
	computeRhoAndDrhoDpAt(
		mgr, reg,
		/*p_name*/ "p_eval",
		/*T_name*/ "T_eval",
		/*phase*/  "water",
		/*rho_out*/     "rho_eval",
		/*drhodp_out*/  "drho_dp_eval"
	);
	// 3.2 旧层密度
	{
		// 临时：再算一次，导数丢掉即可
		computeRhoAndDrhoDpAt(
			mgr, reg,
			/*p_name*/ "p_w_old",
			/*T_name*/ "T_old",
			/*phase*/  "water",
			/*rho_out*/     "rho_old",
			/*drhodp_out*/  "_junk_drdp_old"
		);
	}

	// 4) 压力：扩散 + （θ-版）时间项 + 组装 + 解
	SparseSystemCOO sysP;
	{
		DiffusionIterm_TPFA_water_singlePhase_DarcyFlow(
			mgr, reg, freg, gu, rock.k_iso, Pbc,
			/*a_name*/ "a_f_Diff_p_w",
			/*s_name*/ "s_f_Diff_p_w",
			/*x_name*/ "p_w",
			/*enable_buoy*/ true,
			/*gradSmoothIters*/ 1
		);

		// θ-评估统一版时间项（与温度风格一致）
		TimeTerm_Theta_SinglePhase_Flow(
			mgr, reg, dt, ctrl.c_phi_const,
			/*phi_name*/        "phi",
			/*p_old_name*/      "p_w_old",
			/*rho_old_name*/    "rho_old",
			/*p_eval_name*/     "p_eval",
			/*T_eval_name*/     "T_eval",
			/*rho_eval_name*/   "rho_eval",
			/*drdp_eval_name*/  "drho_dp_eval",
			/*aC_name*/         "aC_time_p",
			/*bC_name*/         "bC_time_p"
		);

		assemblePressure_water_singlePhase_COO(mgr, reg, freg, &sysP);
		const bool needCompressP =
			(ctrl.lin_p.type == LinearSolverOptions::Type::SparseLU) ||
			(ctrl.lin_p.type == LinearSolverOptions::Type::LDLT) ||
			(lastSysP != nullptr);
		if (needCompressP) sysP.compressInPlace(0.0);

		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysP, false);
			PostChecks::printAssemblyReport(R, "P(water)");
		}

		int N = 0; auto lid = buildUnknownMap(mesh, N);
		auto p_vec = gatherFieldToVec(reg, mesh, "p_w", lid, N);
		double resP = 0; int itP = 0; bool okP = false;

		if (!ctrl.useJacobi) {
			auto opt = ctrl.lin_p; if (opt.tol <= 0.0) opt.tol = ctrl.tol_p_abs;
			okP = solveCOO_Eigen(sysP, p_vec, opt, &itP, &resP);
			if (!okP) std::cerr << "[LinearSolver] pressure failed, fallback Jacobi.\n";
		}
		if (ctrl.useJacobi || !okP) {
			jacobiSolve(sysP, p_vec, ctrl.jac_p, &resP, &itP);
		}
		scatterVecToField(reg, mesh, "p_w", lid, p_vec);
	}

	// 5) 温度：扩散 + 对流 + （θ-版）时间项 + 解
	SparseSystemCOO sysT;
	{
		DiffusionIterm_TPFA_Temperature_singlePhase(
			mgr, reg, freg, gu,
			/*lambda_eff*/ "lambda_eff",
			Tbc,
			/*a_f*/ "a_f_Diff_T",
			/*s_f*/ "s_f_Diff_T",
			/*T_field*/ "T"
		);

		Convective_FirstOrder_SinglePhase_Temperature(
			mgr, reg, freg, Tbc,
			/*cp*/ "cp_w",
			/*p*/  "p_w",
			/*T*/  "T",
			/*a_f^p*/ "a_f_Diff_p_w",
			/*s_f^p*/ "s_f_Diff_p_w",
			/*aPP*/ "aPP_conv",
			/*aPN*/ "aPN_conv",
			/*bP*/  "bP_conv"
		);

		// θ-评估统一版温度时间项
		// 此时 rho_r/cp_r/rho_g/cp_g 已由 ppm 在 (p_eval,T_eval) 处更新到字段里
		TimeTerm_Theta_SinglePhase_Temperature
		(
			mgr, reg, dt,
			/*Ceff_floor*/ 1e-12,
			/*phi_name*/   "phi",
			/*rho_r_name*/ "rho_r",
			/*cp_r_name*/  "cp_r",
			/*rho_f_name*/ "rho_w",
			/*cp_f_name*/  "cp_w",
			/*T_old_name*/ "T_old",
			/*aC_name*/    "aC_time_T",
			/*bC_name*/    "bC_time_T",
			/*Ceff_out*/   "Ceff_T"  // 可选诊断输出
		);

		assembleTemperature_singlePhase_COO(
			mgr, reg, freg,
			"a_f_Diff_T", "s_f_Diff_T",
			"aPP_conv", "aPN_conv", "bP_conv",
			"aC_time_T", "bC_time_T",
			&sysT
		);
		const bool needCompressT =
			(ctrl.lin_T.type == LinearSolverOptions::Type::SparseLU) ||
			(ctrl.lin_T.type == LinearSolverOptions::Type::LDLT) ||
			(lastSysT != nullptr);
		if (needCompressT) sysT.compressInPlace(0.0);

		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysT, false);
			PostChecks::printAssemblyReport(R, "T(water)");
		}

		int N = 0; auto lid = buildUnknownMap(mesh, N);
		auto T_vec = gatherFieldToVec(reg, mesh, "T", lid, N);
		double resT = 0; int itT = 0; bool okT = false;

		if (!ctrl.useJacobi) {
			auto opt = ctrl.lin_T; if (opt.tol <= 0.0) opt.tol = ctrl.tol_T_abs;
			okT = solveCOO_Eigen(sysT, T_vec, opt, &itT, &resT);
			if (!okT) std::cerr << "[LinearSolver] temperature failed, fallback Jacobi.\n";
		}
		if (ctrl.useJacobi || !okT) {
			jacobiSolve(sysT, T_vec, ctrl.jac_T, &resT, &itT);
		}
		scatterVecToField(reg, mesh, "T", lid, T_vec);

		//// 可选：温度限幅（若仍想保留）
		//if (auto Tfield = reg.get<volScalarField>("T")) {
		//	for (double& val : Tfield->data) {
		//		if (val < 373.15)      val = 373.15;
		//		else if (val > 450.0)  val = 450.0;
		//	}
		//}
	}

	// 6) 欠松弛 + 收敛衡量
	underRelaxInPlace(reg, "p_w", "p_g_prev", ctrl.urf_p);
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);

	dp_inf = maxAbsDiff(reg, "p_w", "p_g_prev");
	dT_inf = maxAbsDiff(reg, "T", "T_prev");

	updatePrevIterates(reg, "p_w", "T", "p_w_prev", "T_prev");

	if (lastSysP) *lastSysP = sysP;
	if (lastSysT) *lastSysT = sysT;
	return true;
}



// ============ 外迭代驱动（单步） ============
/**
 * @brief 单步外迭代驱动（根据 phase 选择 CO2/WATER 的一次外迭代）
 * @param phase 字符串 "CO2" 或 "water"
 * 其余参数同上。
 */

inline bool outerIter_OneStep_singlePhase(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	const RockDefaults& rock,
	double dt,
	const SolverControls& ctrl,
	const std::string& phase = "CO2"
) {
	// 时间步开始（冻结 *_old，初始化 *_prev）
	if (phase == "CO2" || phase == "co2") {
		if (!startTimeStep(mgr.mesh(), reg, "p_g", "T", "p_g_old", "T_old", "p_g_prev", "T_prev")) return false;
	}
	else if (phase == "water" || phase == "WATER") {
		if (!startTimeStep(mgr.mesh(), reg, "p_w", "T", "p_w_old", "T_old", "p_w_prev", "T_prev")) return false;
	}
	else {
		std::cerr << "[outer] unknown phase: " << phase << "\n";
		return false;
	}

	// 外迭代
	for (int it = 0; it < ctrl.maxOuter; ++it) 
	{
		double dp = 0, dT = 0;
		SparseSystemCOO lastP, lastT;

		bool ok = (phase == "CO2" || phase == "co2")
			? doOneOuter_CO2(mgr, reg, freg, ppm, Pbc, Tbc, gu, rock, dt, ctrl, dp, dT,
				ctrl.dumpMMOnLastIter ? &lastP : nullptr,
				ctrl.dumpMMOnLastIter ? &lastT : nullptr)
			: doOneOuter_WATER(mgr, reg, freg, ppm, Pbc, Tbc, gu, rock, dt, ctrl, dp, dT,
				ctrl.dumpMMOnLastIter ? &lastP : nullptr,
				ctrl.dumpMMOnLastIter ? &lastT : nullptr);
		if (!ok) return false;

		std::cout << "[Outer " << it << "]  |Δp|_inf=" << dp << "  |ΔT|_inf=" << dT << "\n";

		static double prev_dp = 1e300;
		static double prev_dT = 1e300;

		if (it > 0) {
			double rp = dp / std::max(prev_dp, 1e-30);
			double rT = dT / std::max(prev_dT, 1e-30);

			double up = (rp < 0.7) ? +0.05 : (rp > 0.95 ? -0.05 : 0.0);
			double uT = (rT < 0.7) ? +0.05 : (rT > 0.95 ? -0.05 : 0.0);

			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_p = std::min(0.7, std::max(0.15, ctrl_mut.urf_p + up));
			ctrl_mut.urf_T = std::min(0.7, std::max(0.15, ctrl_mut.urf_T + uT));
		}

		prev_dp = dp;
		prev_dT = dT;

		auto maxAbsField = [&](const std::string& fld) -> double 
			{
			double m = 0.0;
			auto f = reg.get<volScalarField>(fld);
			if (!f) return 1.0;
			const auto& cells = mgr.mesh().getCells();
			const auto& id2idx = mgr.mesh().getCellId2Index();
			for (const auto& c : cells) {
				if (c.id < 0) continue;
				size_t i = id2idx.at(c.id);
				m = std::max(m, std::abs((*f)[i]));
			}
			return std::max(1.0, m);
			};

		const std::string pName = (phase == "CO2" || phase == "co2") ? "p_g" : "p_w";
		double pScale = maxAbsField(pName);
		double TScale = maxAbsField("T");

		bool convP = dp < std::max(ctrl.tol_p_abs, ctrl.tol_p_rel * pScale);
		bool convT = dT < std::max(ctrl.tol_T_abs, ctrl.tol_T_rel * TScale);
		if (convP && convT) {
			std::cout << "Converged at outer iter " << it << "\n";
			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				const char* tag = (phase == "CO2" || phase == "co2") ? "CO2" : "WAT";
				PostChecks::dumpCOO_to_matrix_market(lastP, std::string("mm/A_P_") + tag + ".mtx",
					std::string("mm/b_P_") + tag + ".txt", false);
				PostChecks::dumpCOO_to_matrix_market(lastT, std::string("mm/A_T_") + tag + ".mtx",
					std::string("mm/b_T_") + tag + ".txt", false);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting tolerances.\n";
		}
	}
	return true;
}



// 测试函数：2D-常物性-单相-CO2-热扩散问题
inline bool doOneOuters_test_constProperties_singlePhase_CO2_T_diffusion
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dT_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr

)
{
	Mesh& mesh = mgr.mesh();
	if (!startOuterIteration_T(reg, "T", "T_prev")) return false;

	// 利用当前外迭代层的温度场计算物性参数（常物性） 
	ppm.RockProperties_test_constProperties_singlePhase_CO2_T_diffusion(mgr, reg);
	ppm.CO2Properties_test_constProperties_singlePhase_CO2_T_diffusion(mgr, reg);
	ppm.ComputeEffectiveThermalProperties_test_constProperties_singlePhase_CO2_T_diffusion(mgr, reg);

	// 温度扩散方程离散与组装
	// 离散
	{
		// 扩散项
		DiffusionIterm_TPFA_Temperature_singlePhase
		(
			mgr, reg, freg, gu,
			/*lambda_eff*/ "lambda_eff",
			Tbc,
			/*a_f*/ "a_f_Diff_T",
			/*s_f*/ "s_f_Diff_T",
			/*T_field*/ "T"
		);

		//时间项
		TimeTerm_Theta_SinglePhase_Temperature
		(
			mgr, reg, dt,
			/*Ceff_floor*/ 1e-12,
			/*phi_name*/   "phi",
			/*rho_r_name*/ "rho_r",
			/*cp_r_name*/  "cp_r",
			/*rho_f_name*/ "rho_g",
			/*cp_f_name*/  "cp_g",
			/*T_old_name*/ "T_old",
			/*aC_name*/    "aC_time_T",
			/*bC_name*/    "bC_time_T",
			/*Ceff_out*/   "Ceff_T"  // 可选诊断输出
		);
	}
	//组装
	SparseSystemCOO sysT_test;
	{
		const OperatorFieldNames nmT = makeNames("T");  //	取出温度场相关的算子场名
		assemble_COO(mgr, reg, freg, "ddt+laplacian", nmT, &sysT_test);  //
		if (lastSysT) *lastSysT = sysT_test; //

		//打印装配报告
		if (ctrl.reportPerIter)
		{
			auto R = PostChecks::reportAssembly(sysT_test, false);
			PostChecks::printAssemblyReport(R, "T(diffusion, implicit)");
		}
	}

	//求解
	{
		int N = 0; auto lid = buildUnknownMap(mesh, N); //生成待求解变量向量

		auto T_vec = gatherFieldToVec(reg, mesh, "T", lid, N); //从场中提取待求解变量向量

		//求解线性系统

		double resT = 0.0; int itT = 0; bool okT = false;
		auto opt = ctrl.lin_T; //传入线性求解器设置，位于  LinearSolverOptions 结构体内
		if (opt.tol <= 0.0) opt.tol = ctrl.tol_T_abs;

		//调用Eigen求解器,实现方程组的求解
		okT = solveCOO_Eigen(sysT_test, T_vec, opt, &itT, &resT); //输入参数为系数矩阵，待求解向量，线性求解器设置，输出迭代次数和最终残差
		if (!okT) {
			std::cerr << "[LinearSolver] temperature solve failed.\n";
			return false;
		}

		//散射回场
		scatterVecToField(reg, mesh, "T", lid, T_vec);

	}

	//外迭代松弛
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);
	//收敛性检查
	dT_inf = maxAbsDiff(reg, "T", "T_prev");
	updatePrevIterates(reg, { {"T","T_prev"} });

	return true;

}

// 仅温度的外迭代驱动器：2D / 单相 CO2 / 非稳态 / 纯隐式热扩散
inline bool outerIter_test_constProperties_singlePhase_CO2_T_diffusion
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	double dt,
	const SolverControls& ctrl
)
{

	// 外迭代
	double prev_dT = 1e300;

	for (int it = 0; it < ctrl.maxOuter; ++it) {

		double dT = 0.0;
		SparseSystemCOO lastT; //储存上一时层的线性系统矩阵
		bool ok = doOneOuters_test_constProperties_singlePhase_CO2_T_diffusion
		(
			mgr, reg, freg, ppm, Tbc, gu, dt, ctrl, dT, (ctrl.dumpMMOnLastIter ? &lastT : nullptr)
		);

		if (!ok) return false;

		// —— 进度输出 —— 
		std::cout << "[Outer " << it << "]  |ΔT|_inf=" << dT << "\n";

		// —— 松弛因子自适应调整 ——
		if (it > 0) 
		{
			double rT = dT / std::max(prev_dT, 1e-30);
			double uT = (rT < 0.7) ? +0.05 : (rT > 0.95 ? -0.05 : 0.0);
			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_T = std::min(0.7, std::max(0.15, ctrl_mut.urf_T + uT));
		}
		prev_dT = dT;

		auto maxAbsField = [&](const std::string& fld) -> double 
			{
			double m = 0.0;
			auto f = reg.get<volScalarField>(fld);
			if (!f) return 1.0;
			const auto& cells = mgr.mesh().getCells();
			const auto& id2idx = mgr.mesh().getCellId2Index();
			for (const auto& c : cells) {
				if (c.id < 0) continue;
				size_t i = id2idx.at(c.id);
				m = std::max(m, std::abs((*f)[i]));
			}
			return std::max(1.0, m);
			};

		double TScale = maxAbsField("T");
		bool convT = dT < std::max(ctrl.tol_T_abs, ctrl.tol_T_rel * TScale);

		if (convT) {
			std::cout << "Converged at outer iter " << it << "\n";

			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				PostChecks::dumpCOO_to_matrix_market(
					lastT,
					"mm/A_T_CO2_diff.mtx",
					"mm/b_T_CO2_diff.txt",
					/*sym=*/false
				);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting T tolerances.\n";
		}


	}

	return true;

}


//测试函数：2D-变物性-单相-CO2-导热问题

inline bool doOneOuters_test_varyProperties_singlePhase_CO2_T_diffusion(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dT_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr

)
{
	Mesh& mesh = mgr.mesh();
	if (!startOuterIteration_T(reg, "T", "T_prev")) return false;

	ppm.RockProperties_test_constProperties_singlePhase_CO2_T_diffusion(mgr, reg);
	ppm.CO2Properties_test_varProperties_singlePhase_CO2_T_diffusion(mgr, reg, "T");
	ppm.ComputeEffectiveThermalProperties_test_varProperties_singlePhase_CO2_T_diffusion(mgr, reg, "T");

	// 温度扩散方程离散与组装
// 离散
	{
		// 扩散项
		DiffusionIterm_TPFA_Temperature_singlePhase
		(
			mgr, reg, freg, gu,
			/*lambda_eff*/ "lambda_eff",
			Tbc,
			/*a_f*/ "a_f_Diff_T",
			/*s_f*/ "s_f_Diff_T",
			/*T_field*/ "T"
		);

		//时间项
		TimeTerm_Theta_SinglePhase_Temperature
		(
			mgr, reg, dt,
			/*Ceff_floor*/ 1e-12,
			/*phi_name*/   "phi",
			/*rho_r_name*/ "rho_r",
			/*cp_r_name*/  "cp_r",
			/*rho_f_name*/ "rho_g",
			/*cp_f_name*/  "cp_g",
			/*T_old_name*/ "T_old",
			/*aC_name*/    "aC_time_T",
			/*bC_name*/    "bC_time_T",
			/*Ceff_out*/   "Ceff_T"  // 可选诊断输出
		);
	}
	//组装
	SparseSystemCOO sysT_test;
	{
		const OperatorFieldNames nmT = makeNames("T");  //	取出温度场相关的算子场名
		assemble_COO(mgr, reg, freg, "ddt+laplacian", nmT, &sysT_test);  //
		if (lastSysT) *lastSysT = sysT_test; //

		//打印装配报告
		if (ctrl.reportPerIter)
		{
			auto R = PostChecks::reportAssembly(sysT_test, false);
			PostChecks::printAssemblyReport(R, "T(diffusion, implicit)");
		}
	}

	//求解
	{
		int N = 0; auto lid = buildUnknownMap(mesh, N); //生成待求解变量向量

		auto T_vec = gatherFieldToVec(reg, mesh, "T", lid, N); //从场中提取待求解变量向量

		//求解线性系统

		double resT = 0.0; int itT = 0; bool okT = false;
		auto opt = ctrl.lin_T; //传入线性求解器设置，位于  LinearSolverOptions 结构体内
		if (opt.tol <= 0.0) opt.tol = ctrl.tol_T_abs;

		//调用Eigen求解器,实现方程组的求解
		okT = solveCOO_Eigen(sysT_test, T_vec, opt, &itT, &resT); //输入参数为系数矩阵，待求解向量，线性求解器设置，输出迭代次数和最终残差
		if (!okT) {
			std::cerr << "[LinearSolver] temperature solve failed.\n";
			return false;
		}

		//散射回场
		scatterVecToField(reg, mesh, "T", lid, T_vec);

	}

	//外迭代松弛
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);
	//收敛性检查
	dT_inf = maxAbsDiff(reg, "T", "T_prev");
	updatePrevIterates(reg, { {"T","T_prev"} });

	return true;

}
//输入参数 ：网格信息 场信息
inline bool outerIter_test_varyProperties_singlePhase_CO2_T_diffusion
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const GravUpwind& gu,
	double dt,
	const SolverControls& ctrl

)
{
	// 外迭代
	double prev_dT = 1e300;

	for (int it = 0; it < ctrl.maxOuter; ++it) {

		double dT = 0.0;
		SparseSystemCOO lastT; //储存上一时层的线性系统矩阵
		bool ok = doOneOuters_test_varyProperties_singlePhase_CO2_T_diffusion
		(
			mgr, reg, freg, ppm, Tbc, gu, dt, ctrl, dT, (ctrl.dumpMMOnLastIter ? &lastT : nullptr)
		);

		if (!ok) return false;

		// —— 进度输出 —— 
		std::cout << "[Outer " << it << "]  |ΔT|_inf=" << dT << "\n";

		// —— 松弛因子自适应调整 ——
		if (it > 0)
		{
			double rT = dT / std::max(prev_dT, 1e-30);
			double uT = (rT < 0.7) ? +0.05 : (rT > 0.95 ? -0.05 : 0.0);
			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_T = std::min(0.7, std::max(0.15, ctrl_mut.urf_T + uT));
		}
		prev_dT = dT;

		auto maxAbsField = [&](const std::string& fld) -> double
			{
				double m = 0.0;
				auto f = reg.get<volScalarField>(fld);
				if (!f) return 1.0;
				const auto& cells = mgr.mesh().getCells();
				const auto& id2idx = mgr.mesh().getCellId2Index();
				for (const auto& c : cells) {
					if (c.id < 0) continue;
					size_t i = id2idx.at(c.id);
					m = std::max(m, std::abs((*f)[i]));
				}
				return std::max(1.0, m);
			};

		double TScale = maxAbsField("T");
		bool convT = dT < std::max(ctrl.tol_T_abs, ctrl.tol_T_rel * TScale);

		if (convT) {
			std::cout << "Converged at outer iter " << it << "\n";

			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				PostChecks::dumpCOO_to_matrix_market(
					lastT,
					"mm/A_T_CO2_diff.mtx",
					"mm/b_T_CO2_diff.txt",
					/*sym=*/false
				);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting T tolerances.\n";
		}


	}

	return true;


}


//测试函数： 2D-常物性-单相-CO2-达西渗流问题
inline bool doOneOuters_test_constProperties_singlePhase_CO2_p_flow
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dp_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	// 1) 外迭代起步：保存上一迭代值 p_g_prev（同一时间层内）
	if (!startOuterIteration_p(reg, "p_g", "p_g_prev")) return false;

	// 2) 常物性装填（若已装过也没关系）
	ppm.CO2Properties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.RockProperties_test_constProperties_singlePhase_CO2(mgr, reg);

	using FVM::Diffusion::RhoFaceMethod;

	// 3) 面系数（质量形）：a_f,s_f 直接包含“密度1”
	//    关键：mobility_tokens 里带 "rho:rho_g" → MASS_FORM 打开
	const OperatorFieldNames nmP = makeNames("p_g");
	bool ok = FVM::Diffusion::build_FaceCoeffs_Central(
		/*mgr,reg,freg*/ mgr, reg, freg,
		/*a_name*/ nmP.a_f_diff,             // "a_f_Diff_p_g"
		/*s_name*/ nmP.s_f_diff,             // "s_f_Diff_p_g"
		/*x_name*/ "p_g",
		/*mobility_tokens*/
		std::vector<std::string>{ "kxx:kxx", "kyy:kyy", "kzz:kzz", "/mu_g", "rho:rho_g" },
		/*rho_field_for_buoy*/ "rho_g",      // 浮力线性化用ρ（与 MASS_FORM 一致即可）
		/*rho_method*/ RhoFaceMethod::Linear,
		/*g*/ g,
		/*bc*/ Pbc,
		/*enable_buoy*/ true,
		/*gradSmoothIters*/ 0
	);
	if (!ok) return false;

	// 4) 时间项：全隐（用上一时间层 p_g_old 与当前线性化点 p_g_prev）
	ok = TimeTerm_FullyImplicit_SinglePhase_Flow(
		mgr, reg, dt,
		/*c_phi_name   */ "c_phi",
		/*phi_name     */ "phi",
		/*p_old_name   */ "p_g_old",     // 上一时间层 n
		/*rho_old_name */ "rho_g",
		/*p_lin_name   */ "p_g_prev",    // 本层迭代线性化点
		/*rho_lin_name */ "rho_g",
		/*drdp_lin_name*/ "Drho_Dp_g",
		/*aC_name      */ nmP.a_time,    // "aC_time_p_g"
		/*bC_name      */ nmP.b_time     // "bC_time_p_g"
	);
	if (!ok) return false;

	// 5) 组装并求解： TIME + DIFFUSION
	SparseSystemCOO sysP;
	{
		// 你已有两套装配入口，这里沿用“字符串表达式”版本
		assemble_COO(mgr, reg, freg, "ddt+diffusion", nmP, &sysP);
		if (lastSysP) *lastSysP = sysP;

		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysP, false);
			PostChecks::printAssemblyReport(R, "P(Time-implicit + Diffusion (mass-form Darcy))");
		}
	}

	// 6) 线性求解
	int N = 0; auto lid = buildUnknownMap(mesh, N);
	auto pvec = gatherFieldToVec(reg, mesh, "p_g", lid, N);

	auto opt = ctrl.lin_p; if (opt.tol <= 0.0) opt.tol = ctrl.tol_p_abs;
	double res = 0.0; int itL = 0;
	bool okLin = solveCOO_Eigen(sysP, pvec, opt, &itL, &res);
	if (!okLin) { std::cerr << "[LinearSolver] pressure solve failed.\n"; return false; }
	scatterVecToField(reg, mesh, "p_g", lid, pvec);

	// 7) 松弛与收敛度量（同一时间层内）
	underRelaxInPlace(reg, "p_g", "p_g_prev", ctrl.urf_p);
	dp_inf = maxAbsDiff(reg, "p_g", "p_g_prev");
	updatePrevIterates(reg, { {"p_g","p_g_prev"} });

	return true;

}

// 仅压力的外迭代驱动器：2D / 单相 CO2 / 非稳态 / 达西渗流
//输入参数 ：网格信息 场信息
// ================== 外迭代驱动：单相·常物性·CO2·达西渗流（压力） ==================
inline bool outerIter_test_constProperties_singlePhase_CO2_p_flow
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl
)
{
	double prev_dp = 1e300;

	for (int it = 0; it < ctrl.maxOuter; ++it) {

		double dp = 0.0;
		SparseSystemCOO lastP;

		// —— 单步外迭代：装配 TIME+CONVECTION 并求解 —— //
		bool ok = doOneOuters_test_constProperties_singlePhase_CO2_p_flow(
			mgr, reg, freg, ppm, Pbc, g, dt, ctrl,
			/*out*/ dp,
			/*lastSysP*/ (ctrl.dumpMMOnLastIter ? &lastP : nullptr)
		);
		if (!ok) return false;

		// —— 进度输出 —— //
		std::cout << "[Outer " << it << "]  |Δp|_inf=" << dp << "\n";

		// —— 自适应松弛（与温度版同策略）—— //
		if (it > 0) {
			double rp = dp / std::max(prev_dp, 1e-30);
			double up = (rp < 0.7) ? +0.05 : (rp > 0.95 ? -0.05 : 0.0);
			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_p = std::min(0.7, std::max(0.15, ctrl_mut.urf_p + up));
		}
		prev_dp = dp;

		// —— 归一化尺度：用当前 p_g 的最大幅值 —— //
		auto maxAbsField = [&](const std::string& fld)->double {
			double m = 0.0;
			auto f = reg.get<volScalarField>(fld);
			if (!f) return 1.0;
			const auto& cells = mgr.mesh().getCells();
			const auto& id2idx = mgr.mesh().getCellId2Index();
			for (const auto& c : cells) {
				if (c.id < 0) continue;
				size_t i = id2idx.at(c.id);
				m = std::max(m, std::abs((*f)[i]));
			}
			return std::max(1.0, m);
			};

		double Pscale = maxAbsField("p_g");
		bool convP = dp < std::max(ctrl.tol_p_abs, ctrl.tol_p_rel * Pscale);

		if (convP) {
			std::cout << "Converged at outer iter " << it << "\n";
			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				PostChecks::dumpCOO_to_matrix_market(
					lastP,
					"mm/A_P_CO2_flow.mtx",
					"mm/b_P_CO2_flow.txt",
					/*sym=*/false
				);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting P tolerances.\n";
		}
	}
	return true;
}





//测试函数 导热问题
//测试函数： 2D-常物性-单相-CO2-达西渗流问题
inline bool doOneOuters_test_constProperties_singlePhase_CO2_T_newT
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dT_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	// 1) 外迭代起步：保存上一迭代值 p_g_prev（同一时间层内）
	if (!startOuterIteration_T(reg, "T", "T_prev")) return false;

	// 2) 常物性装填（若已装过也没关系）
	ppm.CO2Properties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.RockProperties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.ComputeEffectiveThermalProperties_test_constProperties_singlePhase_CO2_T_diffusion(mgr, reg);

	using FVM::Diffusion::RhoFaceMethod;

	// 3) 面系数（质量形）：a_f,s_f 直接包含“密度1”
	//    关键：mobility_tokens 里带 "rho:rho_g" → MASS_FORM 打开
	const OperatorFieldNames nmT = makeNames("T");
	bool ok = FVM::Diffusion::build_FaceCoeffs_Central(
		/*mgr,reg,freg*/ mgr, reg, freg,
		/*a_name*/ nmT.a_f_diff,             // "a_f_Diff_p_g"
		/*s_name*/ nmT.s_f_diff,             // "s_f_Diff_p_g"
		/*x_name*/ "T",
		/*mobility_tokens*/
		std::vector<std::string>{ "iso:lambda_eff" },
		/*rho_field_for_buoy*/ "",      // 浮力线性化用ρ（与 MASS_FORM 一致即可）
		/*rho_method*/ RhoFaceMethod::Linear,
		/*g*/ Vector{0,0,0},
		/*bc*/ Tbc,
		/*enable_buoy*/ false,
		/*gradSmoothIters*/ 0
	);
	if (!ok) return false;

	// 4) 时间项：全隐（用上一时间层 p_g_old 与当前线性化点 p_g_prev）
	ok = TimeTerm_Theta_SinglePhase_Temperature
	(
		mgr, reg, dt,
		/*Ceff_floor*/ 1e-12,
		/*phi_name*/   "phi",
		/*rho_r_name*/ "rho_r",
		/*cp_r_name*/  "cp_r",
		/*rho_f_name*/ "rho_g",
		/*cp_f_name*/  "cp_g",
		/*T_old_name*/ "T_old",
		/*aC_name*/    "aC_time_T",
		/*bC_name*/    "bC_time_T",
		/*Ceff_out*/   "Ceff_T"  // 可选诊断输出
	);
	if (!ok) return false;

	// 5) 组装并求解： TIME + DIFFUSION
	SparseSystemCOO sysT;
	{
		// 你已有两套装配入口，这里沿用“字符串表达式”版本
		assemble_COO(mgr, reg, freg, "ddt+diffusion", nmT, &sysT);
		if (lastSysP) *lastSysP = sysT;

		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysT, false);
			PostChecks::printAssemblyReport(R, "P(Time-implicit + Diffusion (mass-form Darcy))");
		}
	}

	// 6) 线性求解
	int N = 0; auto lid = buildUnknownMap(mesh, N);
	auto pvec = gatherFieldToVec(reg, mesh, "T", lid, N);

	auto opt = ctrl.lin_T; if (opt.tol <= 0.0) opt.tol = ctrl.tol_T_abs;
	double res = 0.0; int itL = 0;
	bool okLin = solveCOO_Eigen(sysT, pvec, opt, &itL, &res);
	if (!okLin) { std::cerr << "[LinearSolver] pressure solve failed.\n"; return false; }
	scatterVecToField(reg, mesh, "T", lid, pvec);

	// 7) 松弛与收敛度量（同一时间层内）
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);
	dT_inf = maxAbsDiff(reg, "T", "T_prev");
	updatePrevIterates(reg, { {"T","T_prev"} });

	return true;

}

//












// 仅压力的外迭代驱动器：2D / 单相 CO2 / 非稳态 / 达西渗流
//输入参数 ：网格信息 场信息
// ================== 外迭代驱动：单相·常物性·CO2·达西渗流（压力） ==================
inline bool outerIter_test_constProperties_singlePhase_CO2_T_newT
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl
)
{
	double prev_dT = 1e300;

	for (int it = 0; it < ctrl.maxOuter; ++it) {

		double dT = 0.0;
		SparseSystemCOO lastT;

		// —— 单步外迭代：装配 TIME+CONVECTION 并求解 —— //
		bool ok = doOneOuters_test_constProperties_singlePhase_CO2_T_newT(
			mgr, reg, freg, ppm, Tbc, {0,0,0}, dt, ctrl,
			/*out*/ dT,
			/*lastSysP*/ (ctrl.dumpMMOnLastIter ? &lastT : nullptr)
		);
		if (!ok) return false;

		// —— 进度输出 —— //
		std::cout << "[Outer " << it << "]  |ΔT|_inf=" << dT << "\n";

		// —— 自适应松弛（与温度版同策略）—— //
		if (it > 0) {
			double rT = dT / std::max(prev_dT, 1e-30);
			double uT = (rT < 0.7) ? +0.05 : (rT > 0.95 ? -0.05 : 0.0);
			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_T = std::min(0.7, std::max(0.15, ctrl_mut.urf_T + uT));
		}
		prev_dT = dT;

		// —— 归一化尺度：用当前 p_g 的最大幅值 —— //
		auto maxAbsField = [&](const std::string& fld)->double {
			double m = 0.0;
			auto f = reg.get<volScalarField>(fld);
			if (!f) return 1.0;
			const auto& cells = mgr.mesh().getCells();
			const auto& id2idx = mgr.mesh().getCellId2Index();
			for (const auto& c : cells) {
				if (c.id < 0) continue;
				size_t i = id2idx.at(c.id);
				m = std::max(m, std::abs((*f)[i]));
			}
			return std::max(1.0, m);
			};

		double Tscale = maxAbsField("T");
		bool convT = dT < std::max(ctrl.tol_T_abs, ctrl.tol_T_rel * Tscale);

		if (convT) {
			std::cout << "Converged at outer iter " << it << "\n";
			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				PostChecks::dumpCOO_to_matrix_market(
					lastT,
					"mm/A_T_CO2_flow.mtx",
					"mm/b_T_CO2_flow.txt",
					/*sym=*/false
				);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting P tolerances.\n";
		}
	}
	return true;
}



inline bool doOneOutert_constProperties_singlePhase_CO2_pressure
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dp_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	if (!startOuterIteration_scatter(reg, "p_g", "p_g_prev")) return false;

	ppm.CO2Properties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.RockProperties_test_constProperties_singlePhase_CO2(mgr, reg);

	using FVM::Diffusion::RhoFaceMethod;
	const OperatorFieldNames nm = makeNames("p_g");

	bool ok = FVM::Diffusion::build_FaceCoeffs_Central(mgr, reg, freg, nm.a_f_diff, nm.s_f_diff, "p_g", {"kxx:kxx","kyy:kyy","kzz:kzz","/mu_g","rho:rho_g"}, "rho_g", RhoFaceMethod::Linear, g, Pbc, true, 0);
	if (!ok) return false;
	ok = TimeTerm_FullyImplicit_SinglePhase_Flow(mgr, reg, dt, "c_phi", "phi", "p_g_old", "rho_g", "p_g_prev", "rho_g", "Drho_Dp_g", nm.a_time, nm.b_time);
	if (!ok) return false;

	SparseSystemCOO sysp;
	{
		assemble_COO(mgr, reg, freg, "ddt+diffusion", nm, &sysp);
		if (lastSysP) *lastSysP = sysp;
		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysp, false);
			PostChecks::printAssemblyReport(R, "P(Time-implicit + Diffusion (mass-form Darcy))");
		}
	}
	int N = 0; auto lid = buildUnknownMap(mesh, N);
	auto pvec = gatherFieldToVec(reg, mesh, "p_g", lid, N);
	auto opt = ctrl.lin_p; if (opt.tol <= 0.0) opt.tol = ctrl.tol_p_abs;
	double res = 0.0; int itL = 0;
	bool okLin = solveCOO_Eigen(sysp, pvec, opt, &itL, &res);
	if (!okLin) { std::cerr << "[LinearSolver] pressure solve failed.\n"; return false; }
	scatterVecToField(reg, mesh, "p_g", lid, pvec);

	underRelaxInPlace(reg, "p_g", "p_g_prev", ctrl.urf_p);
	dp_inf = maxAbsDiff(reg, "p_g", "p_g_prev");
	updatePrevIterates(reg, { {"p_g","p_g_prev"} });
	return true;



}

inline bool outerIter_constProperties_singlePhase_CO2_Pressure
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl
)
{
	double prev_dp_g = 1e300;
	for (int it = 0; it < ctrl.maxOuter; ++it) 
	{
		double dp  = 0.0;
		SparseSystemCOO lastT;

		//一次外迭代推进
		bool ok = doOneOutert_constProperties_singlePhase_CO2_pressure(mgr, reg, freg, ppm, Pbc, g, dt, ctrl, dp, (ctrl.dumpMMOnLastIter ? &lastT : nullptr));
		if (!ok) return false;

		// —— 进度输出 —— //
		std::cout << "[Outer " << it << "]  |Δp|_inf=" << dp << "\n";

		// —— 自适应松弛—— //
		if (it > 0)
		{
			double rT = dp / std::max(prev_dp_g, 1e-30);
			double uT = (rT < 0.7) ? +0.05 : (rT > 0.95 ? -0.05 : 0.0);
			auto& ctrl_mut = const_cast<SolverControls&>(ctrl);
			ctrl_mut.urf_p = std::min(0.7, std::max(0.15, ctrl_mut.urf_p + uT));
		}
		prev_dp_g = dp;

		auto maxAbsField = [&](const std::string& fld)->double {
			double m = 0.0;
			auto f = reg.get<volScalarField>(fld);
			if (!f) return 1.0;
			const auto& cells = mgr.mesh().getCells();
			const auto& id2idx = mgr.mesh().getCellId2Index();
			for (const auto& c : cells) {
				if (c.id < 0) continue;
				size_t i = id2idx.at(c.id);
				m = std::max(m, std::abs((*f)[i]));
			}
			return std::max(1.0, m);
			};
		double PScale = maxAbsField("p_g");

		bool convP = dp < std::max(ctrl.tol_p_abs, ctrl.tol_p_rel * PScale);

		if (convP) {
			std::cout << "Converged at outer iter " << it << "\n";
			if (ctrl.dumpMMOnLastIter) {
#if __cplusplus >= 201703L
				try { std::filesystem::create_directories("mm"); }
				catch (...) {}
#endif
				PostChecks::dumpCOO_to_matrix_market(
					lastT,
					"mm/A_P_CO2_flow.mtx",
					"mm/b_P_CO2_flow.txt",
					/*sym=*/false
				);
			}
			break;
		}

		if (it == ctrl.maxOuter - 1) {
			std::cout << "Reached maxOuter without meeting P tolerances.\n";
		}
	}
	return true;
}


inline bool doOneOutert_constProperties_singlePhase_CO2_T_H
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dT_inf,
	double& dp_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr
)
{
	Mesh& mesh = mgr.mesh();
	if (!startOuterIteration_scatter(reg, "p_g", "p_g_prev")) return false;
	if (!startOuterIteration_T(reg, "T", "T_prev")) return false;

	ppm.CO2Properties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.RockProperties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.ComputeEffectiveThermalProperties_constProperties_singlePhase_CO2_T_H(mgr, reg);

	using FVM::Diffusion::RhoFaceMethod;
	//压力方程面系数
	const OperatorFieldNames nmP = makeNames("p_g");
	bool ok = FVM::Diffusion::build_FaceCoeffs_Central(mgr, reg, freg, nmP.a_f_diff, nmP.s_f_diff, "p_g", { "kxx:kxx","kyy:kyy","kzz:kzz","/mu_g","rho:rho_g" }, "rho_g", RhoFaceMethod::Linear, g, Pbc, true, 0);
	if (!ok) return false;
	ok = TimeTerm_FullyImplicit_SinglePhase_Flow(mgr, reg, dt, "c_phi", "phi", "p_g_old", "rho_g", "p_g_prev", "rho_g", "Drho_Dp_g", nmP.a_time, nmP.b_time,
		/*strongBCmask=*/nullptr);
	if (!ok) return false;

	//压力方程组装求解
	SparseSystemCOO sysp;
	{
		assemble_COO(mgr, reg, freg, "ddt+diffusion", nmP, &sysp);
		if (lastSysP) *lastSysP = sysp;
		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysp, false);
			PostChecks::printAssemblyReport(R, "P(Time-implicit + Diffusion (mass-form Darcy))");
		}
	}
	int N = 0; auto lid = buildUnknownMap(mesh, N);
	auto pvec = gatherFieldToVec(reg, mesh, "p_g", lid, N);
	auto opt = ctrl.lin_p; if (opt.tol <= 0.0) opt.tol = ctrl.tol_p_abs;
	double res = 0.0; int itL = 0;
	bool okLin = solveCOO_Eigen(sysp, pvec, opt, &itL, &res);
	if (!okLin) { std::cerr << "[LinearSolver] pressure solve failed.\n"; return false; }
	scatterVecToField(reg, mesh, "p_g", lid, pvec);

	underRelaxInPlace(reg, "p_g", "p_g_prev", ctrl.urf_p);
	dp_inf = maxAbsDiff(reg, "p_g", "p_g_prev");
	updatePrevIterates(reg, { {"p_g","p_g_prev"} });

	//温度方程面系数
	std::vector<char>   maskT = mark_strong_BC_cells(mgr, Tbc);
	std::vector<double> Ttar; build_dirichlet_T_targets(mgr, Tbc, maskT, Ttar);

	const double PIN_W = 1e7;

	const OperatorFieldNames nmT = makeNames("T");
	ok = TimeTerm_FullyImplicit_SinglePhase_Temperature(mgr, reg, dt, "C_eff", "T_old", nmT.a_time, nmT.b_time, &maskT, &Ttar, PIN_W);
	if (!ok) return false;
	ok = FVM::Diffusion::build_FaceCoeffs_Central(mgr, reg, freg, nmT.a_f_diff, nmT.s_f_diff, "T", { "iso:lambda_eff" }, "", RhoFaceMethod::Linear, { 0,0,0 }, Tbc, false, 0);
	if (!ok) return false;
	ok = FVM::Convection::buildFlux_Darcy_Mass(mgr, reg, freg, nmP.a_f_diff, nmP.s_f_diff, "p_g", "rho_g", "mf_g", "Qf_g", "ufn_g", &Pbc, true);
	if (!ok) return false;
	ok = FVM::Convection::build_FaceCoeffs_Upwind(mgr, reg, freg, "T", "mf_g", { "cp_g" }, nmT, Tbc);
	if (!ok) return false;

	//温度方程组装求解
	SparseSystemCOO sysT;
	{
		assemble_COO(mgr, reg, freg, "ddt+diffusion+convection", nmT, &sysT);
		if (lastSysT) *lastSysT = sysT;
		if (ctrl.reportPerIter) {
			auto R = PostChecks::reportAssembly(sysT, false);
			PostChecks::printAssemblyReport(R, "T(Time-implicit + Diffusion + Convection)");
		}
	}
	{
		int N = 0; auto lid = buildUnknownMap(mesh, N);
		auto Tvec = gatherFieldToVec(reg, mesh, "T", lid, N);
		auto optT = ctrl.lin_T; if (optT.tol <= 0.0) optT.tol = ctrl.tol_T_abs;
		double resT = 0.0; int itLT = 0;
		bool okLinT = solveCOO_Eigen(sysT, Tvec, optT, &itLT, &resT);
		if (!okLinT) { std::cerr << "[LinearSolver] temperature solve failed.\n"; return false; }
		scatterVecToField(reg, mesh, "T", lid, Tvec);
	}

	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);
	dT_inf = maxAbsDiff(reg, "T", "T_prev");
	updatePrevIterates(reg, { {"T","T_prev"} });
	return true;

}
//================================================================================================================//

inline bool doOneOutert_constProperties_singlePhase_CO2_T_H_withouPIN
(
	MeshManager& mgr,
	FieldRegistry& reg,
	FaceFieldRegistry& freg,
	PhysicalPropertiesManager& ppm,
	const TemperatureBCAdapter& Tbc,
	const PressureBCAdapter& Pbc,
	const Vector& g,
	double dt,
	const SolverControls& ctrl,
	// out
	double& dT_inf,
	double& dp_inf,
	// optional out
	SparseSystemCOO* lastSysP = nullptr,
	SparseSystemCOO* lastSysT = nullptr
)
{
	Mesh& mesh = mgr.mesh();

	// —— 外迭代起步：把上一轮解拷贝到 *_prev，便于欠松弛与收敛评估 —— //
	if (!startOuterIteration_scatter(reg, "p_g", "p_g_prev")) return false;
	if (!startOuterIteration_T(reg, "T", "T_prev")) return false;

	// —— 常物性：更新一次（保持接口一致，后续也可切换变物性） —— //
	ppm.CO2Properties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.RockProperties_test_constProperties_singlePhase_CO2(mgr, reg);
	ppm.ComputeEffectiveThermalProperties_constProperties_singlePhase_CO2_T_H(mgr, reg);

	using FVM::Diffusion::RhoFaceMethod;

	// =========================
	// 1) 压力：时间项 + 达西扩散（质量式）
	// =========================
	const OperatorFieldNames nmP = makeNames("p_g");

	bool ok = FVM::Diffusion::build_FaceCoeffs_Central
	(
		mgr, reg, freg,
		nmP.a_f_diff, nmP.s_f_diff,
		"p_g",
		{ "kxx:kxx","kyy:kyy","kzz:kzz","/mu_g","rho:rho_g" },  // K/mu ⋅ rho_g
		"rho_g", RhoFaceMethod::Linear,
		g, Pbc,
		/*massForm=*/true, /*alpha_anisotropy=*/0
	);
	if (!ok) return false;

	ok = TimeTerm_FullyImplicit_SinglePhase_Flow(
		mgr, reg, dt,
		"c_phi",             // 孔隙度压缩性
		"phi",               // φ^n
		"p_g_old",           // p^n
		"rho_g",             // ρ^n
		"p_g_prev",          // p^⋆
		"rho_g",             // ρ^⋆
		"Drho_Dp_g",         // (∂ρ/∂p)^⋆
		nmP.a_time, nmP.b_time
		/* strongBCmask = */ // 这里不做行覆盖；采用标准边界处理
	);
	if (!ok) return false;

	SparseSystemCOO sysp;
	assemble_COO(mgr, reg, freg, "ddt+diffusion", nmP, &sysp);
	if (lastSysP) *lastSysP = sysp;
	if (ctrl.reportPerIter) {
		auto R = PostChecks::reportAssembly(sysp, /*brief=*/false);
		PostChecks::printAssemblyReport(R, "P(Time-implicit + Diffusion (mass-form Darcy))");
	}

	int Np = 0; auto lid_p = buildUnknownMap(mesh, Np);
	auto pvec = gatherFieldToVec(reg, mesh, "p_g", lid_p, Np);

	auto optP = ctrl.lin_p;
	if (optP.tol <= 0.0) optP.tol = ctrl.tol_p_abs;

	double resP = 0.0; int itP = 0;
	bool okLinP = solveCOO_Eigen(sysp, pvec, optP, &itP, &resP);
	if (!okLinP) return false;

	scatterVecToField(reg, mesh, "p_g", lid_p, pvec);

	underRelaxInPlace(reg, "p_g", "p_g_prev", ctrl.urf_p);
	dp_inf = maxAbsDiff(reg, "p_g", "p_g_prev");
	updatePrevIterates(reg, { {"p_g","p_g_prev"} });

	// =========================
	// 2) 温度：时间项 + 传导 + 对流（无 PIN，强 Dirichlet 行覆盖）
	// =========================

	// 2.1 边界对应的“需要强制”的单元，以及目标 T_b（面积加权）
	std::vector<char>   maskT = mark_strong_BC_cells(mgr, Tbc);
	std::vector<double> Ttar;build_dirichlet_T_targets(mgr, Tbc, maskT, Ttar);

	const OperatorFieldNames nmT = makeNames("T");

	// 时间项（不做 PIN），保持统一装配接口
	ok = TimeTerm_FullyImplicit_SinglePhase_Temperature(
		mgr, reg, dt,
		"C_eff", "T_old",
		nmT.a_time, nmT.b_time
		/* 无需传 mask/pin */
	);
	if (!ok) return false;

	// 传导项
	ok = FVM::Diffusion::build_FaceCoeffs_Central(
		mgr, reg, freg,
		nmT.a_f_diff, nmT.s_f_diff,
		"T",
		{ "iso:lambda_eff" },  // 等效导热系数
		"",
		RhoFaceMethod::Linear,
		{ 0,0,0 }, Tbc,
		/*massForm=*/false, /*alpha_anisotropy=*/0
	);
	if (!ok) return false;

	// 先算达西质量通量/体积通量/法向速度
	ok = FVM::Convection::buildFlux_Darcy_Mass(
		mgr, reg, freg,
		nmP.a_f_diff, nmP.s_f_diff,
		"p_g", "rho_g",
		"mf_g", "Qf_g", "ufn_g", &Pbc, true
	);
	if (!ok) return false;

	// 对流项（一阶迎风；mf × cp）
	ok = FVM::Convection::build_FaceCoeffs_Upwind(
		mgr, reg, freg,
		"T",
		"mf_g",            // 质量通量：内部已避免再次乘 rho
		{ "cp_g" },        // 上风携带物性
		nmT, Tbc
	);
	if (!ok) return false;

	// 组装线性系统
	SparseSystemCOO sysT;
	assemble_COO(mgr, reg, freg, "ddt+diffusion+convection", nmT, &sysT);
	if (lastSysT) *lastSysT = sysT;
	if (ctrl.reportPerIter) {
		auto R = PostChecks::reportAssembly(sysT, /*brief=*/false);
		PostChecks::printAssemblyReport(R, "T(Time-implicit + Diffusion + Convection)");
	}

	// 强 Dirichlet 行覆盖（无 PIN）
	int Nt = 0; auto lid_t = buildUnknownMap(mesh, Nt);
	apply_strong_dirichlet_rows_T(lid_t, maskT, Ttar, sysT);

	// 求解
	auto Tvec = gatherFieldToVec(reg, mesh, "T", lid_t, Nt);

	auto optT = ctrl.lin_T;
	if (optT.tol <= 0.0) optT.tol = ctrl.tol_T_abs;

	double resT = 0.0; int itT = 0;
	bool okLinT = solveCOO_Eigen(sysT, Tvec, optT, &itT, &resT);
	if (!okLinT) return false;

	scatterVecToField(reg, mesh, "T", lid_t, Tvec);

	// 欠松弛 + 收敛
	underRelaxInPlace(reg, "T", "T_prev", ctrl.urf_T);
	dT_inf = maxAbsDiff(reg, "T", "T_prev");
	updatePrevIterates(reg, { {"T","T_prev"} });

	return true;
}
//================================================================================================================//

```


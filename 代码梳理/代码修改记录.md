在求解器流程部分，梳理顺序，自底层至顶层：



1. 参考“inline bool startOuterIteration”函数 添加了,将 压力和温度变量分开，提高灵活性

   ```c++
   // 3—1） 外迭代开始：把 prev (k层) 拷到当前工作场-变量T
   inline bool startOuterIteration_T
   (
   	FieldRegistry& reg,
   	const std::string& T_name = "T",
   	const std::string& T_prev_name = "T_prev"
   )
   {
       bool ok = true;
       ok = ok && copyField(reg, T_prev_name, T_name);
       return ok;
   }
   
   // 3—2） 外迭代开始：把 prev (k层) 拷到当前工作场-变量p
   inline bool startOuterIteration_p
   (
       FieldRegistry& reg,
       const std::string& p_name = "p_w",
       const std::string& p_prev_name = "p_w_prev"
   )
   {
       bool ok = true;
       ok = ok && copyField(reg, p_prev_name, p_name);
       return ok;
   }
   
   ```

   **函数功能**：外迭代开始：把 prev (k层) 拷到当前工作场-变量T

 

1. 根据已有的inline bool ensureTransientFields函数，仿写添加了 

   ```c++
   inline bool ensureTransientFields_test_singlePhase_CO2_T_diffusion(Mesh& mesh, FieldRegistry& reg, const std::string& T_name = "T", const std::string& T_old_name = "T_old", const std::string& T_prev_name = "T_prev")
   {
       const auto& cells = mesh.getCells();
       const auto& id2idx = mesh.getCellId2Index();
       const size_t n = cells.size();
       auto T = reg.get<volScalarField>(T_name);
       auto ensureSized = [&](const std::string& name, std::shared_ptr<volScalarField>& out) -> bool
           {
               out = reg.get<volScalarField>(name);
   
               bool created_or_resized = false;
   
               if (!out)
               {
                   out = reg.getOrCreate<volScalarField>(name, n, 0.0);
                   created_or_resized = true;
               }
   
               else if (out->data.size() != n)
               {
                   out->data.resize(n, 0.0);
                   created_or_resized = true;
               }
   
               return created_or_resized;
           };
   
       std::shared_ptr<volScalarField> T_old, T_prev;
     
       const bool need_init_T_old = ensureSized(T_old_name, T_old);
       
       const bool need_init_T_prev = ensureSized(T_prev_name, T_prev);
   
       // 若新建或尺寸变化，用当前 p/T 初始化 *_old 与 *_prev
       if ( need_init_T_old  || need_init_T_prev) {
           for (const auto& c : cells) {
               if (c.id < 0) continue;          // 跳过 ghost
               const size_t i = id2idx.at(c.id);
               
               if (need_init_T_old)  (*T_old)[i] = (*T)[i];
               
               if (need_init_T_prev) (*T_prev)[i] = (*T)[i];
           }
       }
       return true;
   }
   ```

   

    **函数功能**：判断温度T的迭代层场T_prev、上一时层场T_old是否存在过尺寸变化，如果不存在过尺寸不等，则进行create并用当前T场对T_prev和T_old进行初始化。

 

 

   2.根据已有的 inline bool startTimeStep 函数，仿写添加了

```c++
	inline bool startTimeStep_test_singlePhase_CO2_T_diffusion
(
	Mesh& mesh, FieldRegistry& reg,
	const std::string& T_name = "T",
	const std::string& T_old_name = "T_old",
	const std::string& T_prev_name = "T_prev"
)
{
	if (!ensureTransientFields_test_singlePhase_CO2_T_diffusion(mesh, reg, T_name, T_old_name, T_prev_name)) return false;
	// T^n
	if (!copyField(reg, T_name, T_old_name)) return false; //将T 复制到_old
	// prev ← old (给 k=0 的外迭代作为初值)
	if (!copyField(reg, T_old_name, T_prev_name)) return false; //将T_old 复制到 T_prev
	return true;
}

```


​	**函数功能**：封装“ensureTransientFields_test_singlePhase_CO2_T_diffusion”函数和“copyField”函数 实现迭代层场T_prev、上一时层场T_old的创建以及用当前T场对T_prev和T_old进行初始化



3. 根据已有的系数矩阵组装子函数，拆分成三部分，对流项系数矩阵组装、扩散项组装和时间项组装

   ```c++
   inline bool assembleTemperature_singlePhase_COO
   (
       MeshManager& mgr,
       const FieldRegistry& reg,
       const FaceFieldRegistry& freg,
       // 扩散面账本
       const std::string& a_face_diff = "a_f_Diff_T",
       const std::string& s_face_diff = "s_f_Diff_T",
       // 对流项面账本
       const std::string& aPP_conv = "aPP_conv",
       const std::string& aPN_conv = "aPN_conv",
       const std::string& bP_conv = "bP_conv",
       // 时间项
       const std::string& a_time = "aC_time_T",
       const std::string& b_time = "bC_time_T",
       SparseSystemCOO* out = nullptr
   ) {
       Mesh& mesh = const_cast<Mesh&>(mgr.mesh());
       const auto& faces = mesh.getFaces();
       const auto& cells = mesh.getCells();
       const auto& id2idx = mesh.getCellId2Index();
   
       auto aF = freg.get<faceScalarField>(a_face_diff);
       auto sF = freg.get<faceScalarField>(s_face_diff);
       auto aPP = freg.get<faceScalarField>(aPP_conv);
       auto aPN = freg.get<faceScalarField>(aPN_conv);
       auto bPc = freg.get<faceScalarField>(bP_conv);
       auto aC = reg.get<volScalarField>(a_time);
       auto bC = reg.get<volScalarField>(b_time);
   
       if (!aF || !sF || !aPP || !aPN || !bPc || !aC || !bC) {
           std::cerr << "[assembleTemperature] missing diffusion/conv/time fields.\n";
           return false;
       }
   
       int N = 0;
       const auto lid_of_cell = buildUnknownMap(mesh, N);
       if (!out) return true;
       out->reset(N, /*reserveA*/ faces.size() * 6 + cells.size() * 2);
   
       // 1) 扩散贡献（与压力相同的装配法则）
       for (const auto& F : faces) {
           const int iF = F.id - 1;
           const double af = (*aF)[iF];
           const double sf = (*sF)[iF];
           const int Pid = F.ownerCell;
           const int Nid = F.neighborCell;
           const int iP = (Pid >= 0 ? id2idx.at(Pid) : -1);
           const int iN = (Nid >= 0 ? id2idx.at(Nid) : -1);
           const int rP = (iP >= 0 ? lid_of_cell[iP] : -1);
   
           if (F.isBoundary()) {
               if (rP >= 0) { out->addA(rP, rP, af); out->addb(rP, sf); }
               continue;
           }
           const int rN = (iN >= 0 ? lid_of_cell[iN] : -1);
           if (rP >= 0 && rN >= 0) {
               out->addA(rP, rP, af);
               out->addA(rP, rN, -af);
               out->addb(rP, sf);
               out->addA(rN, rN, af);
               out->addA(rN, rP, -af);
               out->addb(rN, -sf);
           }
       }
   
       // 2) 对流贡献（双侧守恒）
       for (const auto& F : faces) {
           const int iF = F.id - 1;
           const int Pid = F.ownerCell;
           const int Nid = F.neighborCell;
           const int iP = (Pid >= 0 ? id2idx.at(Pid) : -1);
           const int iN = (Nid >= 0 ? id2idx.at(Nid) : -1);
           const int rP = (iP >= 0 ? lid_of_cell[iP] : -1);
   
           const double aPPf = (*aPP)[iF];
           const double aPNf = (*aPN)[iF];
           const double bPf = (*bPc)[iF];
   
           if (F.isBoundary()) {
               if (rP >= 0) {
                   if (aPPf != 0.0) out->addA(rP, rP, aPPf); // 出流
                   if (bPf != 0.0) out->addb(rP, bPf);   // 入流
               }
               continue;
           }
           const int rN = (iN >= 0 ? lid_of_cell[iN] : -1);
           if (rP < 0 || rN < 0) continue;
   
           if (aPPf > 0.0) {
               // owner 出流
               out->addA(rP, rP, aPPf);
               out->addA(rN, rP, -aPPf);
           }
           else if (aPNf != 0.0) {
               // owner 入流（aPN <= 0）
               out->addA(rP, rN, aPNf);
               out->addA(rN, rN, -aPNf);
           }
           // 内部面对流没有 b 源（你已在内部面把 bP_conv 置 0）
       }
   
       // 3) 时间项
       for (const auto& c : cells) {
           if (c.id < 0) continue;
           const size_t i = id2idx.at(c.id);
           const int r = lid_of_cell[i];
           if (r < 0) continue;
           out->addA(r, r, (*aC)[i]);
           out->addb(r, (*bC)[i]);
       }
       return true;
   }
   ```

最后形成的函数为

```C++
inline bool assemble_COO
(
    MeshManager& mgr, const FieldRegistry& reg, const FaceFieldRegistry& freg,
    const std::string& op_expr, const OperatorFieldNames& nm, SparseSystemCOO* out
)
{
    std::string err;
    unsigned mask = parse_ops(op_expr, &err);
    if (mask == OP_NONE && !err.empty()) { std::cerr << "[assemble] parse_ops error: " << err << "\n"; return false; }
    return  assemble_sparse_system_coo_item(mgr, reg, freg, mask, nm, out);
}
```

其中，assemble_sparse_system_coo_item(mgr, reg, freg, mask, nm, out)具体函数定义为：

```C++
bool assemble_sparse_system_coo_item
(
    MeshManager& mgr,
    const FieldRegistry& reg,
    const FaceFieldRegistry& freg,
    unsigned ops, 
    const OperatorFieldNames& nm,
    SparseSystemCOO* out
)
{
    Mesh& mesh = const_cast<Mesh&>(mgr.mesh());
    const auto& faces = mesh.getFaces();
    const auto& cells = mesh.getCells();
    const auto& id2idx = mesh.getCellId2Index();

    // —— 取字段（注意：get 返回 shared_ptr，这里先接住，再 .get()） —— //
    std::shared_ptr<faceScalarField> aF_sp, sF_sp, aPP_sp, aPN_sp, bPc_sp;
    std::shared_ptr<volScalarField>  aC_sp, bC_sp;

    if (has(ops, OP_DIFFUSION)) {
        aF_sp = freg.get<faceScalarField>(nm.a_f_diff);
        sF_sp = freg.get<faceScalarField>(nm.s_f_diff);
        if (!aF_sp || !sF_sp) { std::cerr << "[assemble] missing diffusion fields.\n"; return false; }
    }
    if (has(ops, OP_CONVECTION)) {
        aPP_sp = freg.get<faceScalarField>(nm.aPP_conv);
        aPN_sp = freg.get<faceScalarField>(nm.aPN_conv);
        bPc_sp = freg.get<faceScalarField>(nm.bP_conv);
        if (!aPP_sp || !aPN_sp || !bPc_sp) { std::cerr << "[assemble] missing convection fields.\n"; return false; }
    }
    if (has(ops, OP_TIME)) {
        aC_sp = reg.get<volScalarField>(nm.a_time);
        bC_sp = reg.get<volScalarField>(nm.b_time);
        if (!aC_sp || !bC_sp) { std::cerr << "[assemble] missing time fields.\n"; return false; }
    }

    // —— 建未知量编号 —— //
    int N = 0;
    const auto lid_of_cell = buildUnknownMap(mesh, N);
    if (!out) return true;

    // —— 估算 nnz 并 reset —— //
    size_t reserveA = 0;
    if (has(ops, OP_DIFFUSION))  reserveA += faces.size() * kReservePerFaceDiff;
    if (has(ops, OP_CONVECTION)) reserveA += faces.size() * kReservePerFaceConv;
    if (has(ops, OP_TIME))       reserveA += cells.size() * kReservePerCellTime;
    out->reset(N, reserveA);

    // —— 只读上下文（使用原生指针，作用域内 shared_ptr 保活） —— //
    const faceScalarField* aF = aF_sp ? aF_sp.get() : nullptr;
    const faceScalarField* sF = sF_sp ? sF_sp.get() : nullptr;
    const faceScalarField* aPP = aPP_sp ? aPP_sp.get() : nullptr;
    const faceScalarField* aPN = aPN_sp ? aPN_sp.get() : nullptr;
    const faceScalarField* bPc = bPc_sp ? bPc_sp.get() : nullptr;
    const volScalarField* aC = aC_sp ? aC_sp.get() : nullptr;
    const volScalarField* bC = bC_sp ? bC_sp.get() : nullptr;


    AssembleCtx Ctx{
        mesh, faces, cells, id2idx, lid_of_cell,
        aF, sF, aPP, aPN, bPc, aC, bC
    };

    // —— 分支装配 —— //
    if (has(ops, OP_DIFFUSION))  assemble_diffusion_faces(Ctx, *out);
    if (has(ops, OP_CONVECTION)) assemble_convection_faces(Ctx, *out);
    if (has(ops, OP_TIME))       assemble_time_cells(Ctx, *out);

    return true;


}
```

**实现功能**：可实现根据输入字段分别对流项系数矩阵组装、扩散项组装和时间项组装

**调用示例**

```c++
const OperatorFieldNames nmT = makeNames("T");  //	取出温度场相关的算子场名
assemble_COO(mgr, reg, freg, "ddt+laplacin", nmT, &sysT_test);  //
```



4. 根据当前外迭代推进函数，updatePrevIterates，改写为可根据输入的变量名称进行推进的通用函数形式。

   ```C++
   
   
   // 2) 多变量显式配对：完全自定义目标名
   inline bool updatePrevIterates(FieldRegistry& reg,
                                  const std::initializer_list<std::pair<std::string,std::string>>& pairs)
   {
       bool ok = true;
       for (const auto& pr : pairs) {
           ok = ok && copyField(reg, pr.first, pr.second);
       }
       return ok;
   }
   
   
   ```

   使用示例

   ```c++
   
   updatePrevIterates(reg, { {"T","T_prev"}, {"p_g","p_old"} }); //多变量
   
   updatePrevIterates(reg, { {"T","T_prev"} }); //单变量
   
   ```

   
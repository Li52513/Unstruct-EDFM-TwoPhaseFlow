```c++
1 "MeshManager.h"
	|--"Mesh.h"
	|--"FractureNetwork.h"
	|--"BoundaryFaceClassify.h"

	1.1 "Mesh.h"														
        |--"Node,h"
        |--"Face.h"
        |--"Cell.h"
    
    1.2"FractureNetwork.h"
       |--"Fracture.h"
    
          1.2.1"Fracture.h"
                |--"Node,h"
                |--"Face.h"
                |--"Cell.h"
                |--"FractureSolidProperties.h " (待抽离)
    
    1.3"BoundaryFaceClassify.h"
         |-- "Mesh.h"  
```



```C++
///1 "MeshManager.h"的具体代码实现
#include "MeshManager.h"
#include "FractureNetwork.h"
MeshManager::MeshManager(double lx, double ly, double lz,
    int nx, int ny, int nz,
    bool usePrism, bool useQuadBase)
    : lx_(lx), ly_(ly), lz_(lz),
    nx_(nx), ny_(ny), nz_(nz),
    usePrism_(usePrism), useQuadBase_(useQuadBase)
{
    cout<<"调用MeshManager构造函数并初始化"<< "\n";
}
void MeshManager::BuildSolidMatrixGrid(NormalVectorCorrectionMethod corr) 
{
    mesh_.BuildMesh(lx_, ly_, lz_, nx_, ny_, nz_, usePrism_, useQuadBase_);
    mesh_.ClassifySolidMatrixCells();       //用于区分内部单元和边界单元
    bcGroups_ = BoundaryFaceClassify::ClassifyBoundaryFaces(mesh_, lx_, ly_,lz_,1e-9);
    // 2) 可选：统计所有边界面（用于自检）
    boundaryCount_ = 0;
    for (const auto& f : mesh_.getFaces()) if (f.isBoundary()) ++boundaryCount_;
    // 3) （可选）自检打印
    std::cout << "[BC] faces: x0=" << bcGroups_.x0.size()
        << " xL=" << bcGroups_.xL.size()
        << " y0=" << bcGroups_.y0.size()
        << " yL=" << bcGroups_.yL.size()
        << " z0=" << bcGroups_.z0.size()
        << " zL=" << bcGroups_.zL.size()
        << " | total boundary=" << boundaryCount_ << "\n";

    mesh_.ComputeSolidMatrixMeshFaceGeometricInfor(corr);
}
void MeshManager::addFracture(const Vector& s, const Vector& e) 
{
    frNet_.addFracture(s, e);
}
void MeshManager::DetectAndSubdivideFractures() 
{
    // 1) 先找裂缝–裂缝的交点
    frNet_.DetectFracturetoFractureIntersections();
    
    bool useAABBAcceleration = false;  // 或 false 用于对比测试
    int totalFaces = mesh_.getFaces().size();
    int totalCandidates = 0;

	// 2) 然后找裂缝–网格面的交点  可以选取AABB加速算法
    for (auto& F : frNet_.fractures)
    {
		if (useAABBAcceleration)
		{
			F.computeAABB(); // 计算每条裂缝的 AABB 边界框
			F.DetectFracturetoMeshFaceIntersections(mesh_, mesh_.getCells(), mesh_.getNodesMap(), true);
            totalCandidates += F.candidateFaceCount_; // 候选面数
		}
        else
        {
            F.DetectFracturetoMeshFaceIntersections(mesh_, mesh_.getCells(), mesh_.getNodesMap(), false);
            totalCandidates += totalFaces; // 所有面都遍历
        }

    }
    std::cout << "[加速效果] 总面数 = " << totalFaces
        << ", 总裂缝数 = " << frNet_.fractures.size()
        << ", 总候选面数 = " << totalCandidates
        << ", 平均每条裂缝面数 = " << (double)totalCandidates / frNet_.fractures.size()
        << ", 剔除率 = " << (100.0 - 100.0 * totalCandidates / (totalFaces * frNet_.fractures.size()))
        << "%\n";

    // 3) 给全局裂缝–裂缝交点去重并编号
    frNet_.DeduplicateAndRenumberFractureToFractureIntersections();
    
    // 4) 把全局裂缝–裂缝交点也插入到每条裂缝的 intersections 中
    frNet_.DistributeFracture_FractureIntersectionsToGlobalInersections();

    // 5) 重新排序 & 编号，然后划分
    for (auto& F : frNet_.fractures)
    {
        F.sortAndRenumberIntersections();
        /*F.subdivide(mesh_.getCells(), mesh_.getNodesMap(),true);*/
        F.subdivide(mesh_.getCells(), mesh_.getNodesMap(), distanceMetric_);
    }
}
void MeshManager::ComputeFractureGeometryCouplingCoefficient()
{
    for (auto& F : frNet_.fractures)
        F.computeGeometryCouplingCoefficientgeomCIandgeomAlpha();
}
void MeshManager::setDFNRandomSeed(unsigned seed)
{
	frNet_.setRandomSeed(seed);
}
void MeshManager::generateDFN(
    int N,
    const Vector& minPoint,
    const Vector& maxPoint,
    double Lmin,
    double Lmax,
    double alpha,
    double kappa,
    bool avoidOverlap)
{
	frNet_.generateDFN(N, minPoint, maxPoint, Lmin, Lmax, alpha, kappa, avoidOverlap);
}

void MeshManager::exportMesh(const std::string& pref) const {
    mesh_.exportToTxt(pref);
}

void MeshManager::exportFractures(const std::string& pref) const {
    frNet_.exportToTxt(pref);
}

void MeshManager::printFractureInfo() const {
    frNet_.printFractureInfo();
}

void MeshManager::printCISourceTerms()  
{
    std::cout << "\n=== 检查基岩–裂缝 CI 源项 ===\n";
    for (auto& cell : mesh_.getCells())
    {
        if (cell.id < 0) continue;               // 跳过 Ghost
        if (cell.CI.empty())     continue;       // 没有 fracture 交互就跳过

        std::cout << "Cell " << cell.id << ":\n";
        for (size_t k = 0; k < cell.CI.size(); ++k) {
            std::cout
                << "  SegID=" << cell.CI_belongFraction[k]
                << "  CI=" << cell.CI[k]
                << "  p_fr(cell)=" << cell.fracturePressure[k]
                << "\n";
        }
    }
}

```

```c++
/// 1.1 Mesh.h的具体代码实现
#include "Mesh.h"
#include <iostream>
#include <algorithm>
#include <map>
#include <gmsh.h>
#include <set>
#include <cmath>
#include "Bound.h"
#include <unordered_set>

Mesh::Mesh() : gridCount_(0) {}

void Mesh::BuildMesh(double lengthX, double lengthY, double lengthZ, int nx, int ny, int nz, bool usePrism, bool useQuadBase)
{     
	// 0) 初始化 Gmsh
    gmsh::initialize();
    gmsh::model::add("UnstructuredMesh-EDFM");

    // 视作 2D 的条件：长度Z<=0 或者 nz==0
    const bool is2D = (lengthZ <= 0.0 || nz <= 0);
    double lc = -1.0;

    // ---- 通用：构造一个矩形底面几何（2D面 or 3D的底面） ----
    {
        // 尺寸：按目标网格数估算平均特征长度
        lc = std::min(lengthX / std::max(nx, 1), lengthY / std::max(ny, 1));
        // 顶点
        int p1 = gmsh::model::geo::addPoint(0, 0, 0, lc);
        int p2 = gmsh::model::geo::addPoint(lengthX, 0, 0, lc);
        int p3 = gmsh::model::geo::addPoint(lengthX, lengthY, 0, lc);
        int p4 = gmsh::model::geo::addPoint(0, lengthY, 0, lc);

        // 边
        int l1 = gmsh::model::geo::addLine(p1, p2);
        int l2 = gmsh::model::geo::addLine(p2, p3);
        int l3 = gmsh::model::geo::addLine(p3, p4);
        int l4 = gmsh::model::geo::addLine(p4, p1);

        // 面
        int loop = gmsh::model::geo::addCurveLoop({ l1, l2, l3, l4 });
        int surface = gmsh::model::geo::addPlaneSurface({ loop });

        // ---- 二维网格类型：三角形 or 四边形（非结构化） ----
        if (useQuadBase)
        {
            //非结构化四边形
            gmsh::option::setNumber("Mesh.RecombineAll", 1);  // 三角→四边形重组
            gmsh::option::setNumber("Mesh.Algorithm", 4);     // 8Quad 前沿法（更稳）
            gmsh::option::setNumber("Mesh.RecombinationAlgorithm", 2); // blossom
        }
        else
        {
            // 非结构化三角
            gmsh::option::setNumber("Mesh.RecombineAll", 0);
            gmsh::option::setNumber("Mesh.Algorithm", 6);     // Frontal-Delaunay
        }
        // 优化
        gmsh::option::setNumber("Mesh.Optimize", 1);
        gmsh::option::setNumber("Mesh.Smoothing", 2);

        //改动：添加
        gmsh::model::geo::synchronize();
        gmsh::model::mesh::generate(2);

        //------如果需要生成三维网格，则沿z方向扫掠---
        if (!is2D && usePrism)
        {
            //改动：添加
            gmsh::option::setNumber("Mesh.SubdivisionAlgorithm", 0);
            gmsh::option::setNumber("Mesh.ElementOrder", 1);

            gmsh::vectorpair base = { {2, surface} };
            gmsh::vectorpair outDimTags;

            // 非均匀层厚：如果 setLayerHeights() 提供了配置(待添加），就用它；否则均分 nz
            std::vector<int>    numElems;   // 通常给 {nz}
            std::vector<double> heights;    // 或者给每层厚度
            numElems = { std::max(nz, 1) };  //均分z方向网格

            // 选择是否重组：三角底 → 棱柱（recombine=false）；四边形底 → 六面体网格（recombine=true），由于gmsh在拉伸生成非结构化棱柱网格时候底面只能为三角形网格
            bool recombineForHex = useQuadBase;
            if (!useQuadBase) {
                std::cout << "[INFO] 3D 扫掠：三角底 → 生成棱柱(type=6)。" << std::endl;
            }
            else {
                std::cout << "[INFO] 3D 扫掠：四边形底 → 生成六面体(type=5)。" << std::endl;
            }
           
            //扫掠
            gmsh::model::geo::extrude
            (
                base, 0, 0, lengthZ,
                outDimTags,
                numElems,            // 均分层数
                heights,             // 或者非均匀层厚
                /*recombine=*/true   //将三角形进行合并 才能生成棱柱网格，如果是false 当底面为非结构化四边形的时候也可以生成六面体网格，但是当底面为三角形时生成的史四面体网格。 三角底: true→棱柱(type=6), false→四面体(type=4) 四边底: true→六面体(type=5), false→四面体(type=4)
            );

            gmsh::model::geo::synchronize();
            gmsh::model::mesh::generate(3);

        }

    }  

    // === Step 1: 获取所有节点，并建立 ID → 坐标 的映射 ===
    vector<size_t> nodeTags;            ///< GMSH节点ID集合
    vector<double> nodeCoords;          ///< 节点坐标扁平化数组 [x1,y1,z1,x2,y2,z2,...]
    vector<double> parametricCoords;    ///< 参数坐标
    // 调用GMSH API获取网格节点数据
    gmsh::model::mesh::getNodes(nodeTags, nodeCoords, parametricCoords);
    nodes_.clear(); nodes_.reserve(nodeTags.size());//清除nodes_并预留空间
    nodesMap_.clear(); nodesMap_.reserve(nodeTags.size()); //清除nodesMap_并预留空间

    // 处理所有节点数据
    for (size_t i = 0; i < nodeTags.size(); i++)
    {
        // 转换节点ID类型: size_t → int (GMSH → 本地系统)
		int id = static_cast<int>(nodeTags[i]); 

        // 提取节点三维坐标 (x, y, z)
		Vector coord(
            nodeCoords[3 * i],          // X坐标
            nodeCoords[3 * i + 1],      // Y坐标
			nodeCoords[3 * i + 2]		// Z坐标
        );

        // 将节点添加到线性容器（保持原始顺序）
        nodes_.emplace_back(id, coord);  

        // 将节点添加到映射表（便于通过ID快速查找）
        nodesMap_[id] = Node(id, coord);   
    }

    // ==== Step 2: 读取单元信息，识别组成单元的网格节点，计算终点坐标和体积大小，从而构建 Cell（支持三角形和四面体）数据类型====

	vector<int> elementTypes;                               //储存单元类型
	vector<vector<size_t>> elementTags, nodeTagsPerElement;  //二维数组，按照单元类型储存单元标签和组成单元的节点信息

    // 获取网格信息（is2D-True-2D网格，False-3D网格)
	gmsh::model::mesh::getElements(elementTypes, elementTags, nodeTagsPerElement, is2D ? 2 : 3);  

    cells_.clear();
    // 处理所有单元类型
    for (size_t i = 0; i < elementTypes.size(); i++)
    {
        int type = elementTypes[i]; //获取网格类型
        std::cout << "Element type = " << elementTypes[i] << endl;

        // 三角形单元（2D） 1=线单元, 2=三角形, 3=四边形  其他网格类型待补充
        std::cout << "------------Cell全局编号和坐标信息------------" << endl;

        if (is2D && type == 2)
        { 
            size_t numTriangles = elementTags[i].size();    //有多少个三角形网格单元
            
            std::cout << "Element numbers = " << numTriangles << endl;
            
            //遍历每一个网格单元
            for (size_t j = 0; j < numTriangles; j++)               
            {
				int cellId = static_cast<int>(elementTags[i][j]);   // 读取网格单元局部编号
				//cout << "Cell ID = " << cellId << endl;
				vector<int> cellNodeIDs;                            //建立储存单元节点编号的容器  **建立cell与Node之间的连接关系
               
                // 提取三角形单元的三个节点
                for (int k = 0; k < 3; k++)
				{
                    // 三角形单元有三个节点，其中 k=0,1,2 分别对应三个节点 //局部编号
                
                    cellNodeIDs.push_back(static_cast<int>(nodeTagsPerElement[i][3 * j + k]));  
					//cout << "Node ID = " << cellNodeIDs[k] << endl<<endl;
                    
				}
                
                // 创建Cell对象并计算几何属性
                Cell cell(cellId, cellNodeIDs);
                //cout <<"------编号为"<< cellId<<"的Cell中心点和面积信息--------"  << endl;
                cell.computeCenterAndVolume(nodesMap_);
                cells_.push_back(cell);
               // cout << "------------------------------------------------" << endl;
            }
        }
        else if (is2D && type == 3)
        {
            size_t n = elementTags[i].size();
            std::cout << "Element numbers = " << n << endl;
            for (size_t j = 0; j < n; ++j)
            {
                int cellId = static_cast<int>(elementTags[i][j]);
                vector<int> cellNodeIDs;
                for (int k = 0; k < 4; k++)
                {
                    // 四边形单元有四个节点，其中 k=0,1,2,3 分别对应四个节点 //局部编号

                    cellNodeIDs.push_back(static_cast<int>(nodeTagsPerElement[i][4 * j + k]));
                    cout << "Node ID = " << cellNodeIDs[k] << endl << endl;

                }
                // 创建Cell对象并计算几何属性
                Cell cell(cellId, cellNodeIDs);
                //cout <<"------编号为"<< cellId<<"的Cell中心点和面积信息--------"  << endl;
                cell.computeCenterAndVolume(nodesMap_);
                cells_.push_back(cell);
                // cout << "------------------------------------------------" << endl;
            }
        }
        // 四面体单元（3D）4=四面体 5=六面体 6=棱柱 7=金字塔
        else if (!is2D && type == 4)
        {
            size_t numTets = elementTags[i].size();
            for (size_t j = 0; j < numTets; j++)
            {
				int cellId = static_cast<int>(elementTags[i][j]); // 读取单元编号
				vector<int> cellNodeIDs;                         //建立储存单元节点编号的容器
				for (int k = 0; k < 4; k++)                      // 四面体单元有四个节点
                    cellNodeIDs.push_back(static_cast<int>(nodeTagsPerElement[i][4 * j + k]));

				Cell cell(cellId, cellNodeIDs);       // 构造 Cell 对象
				cell.computeCenterAndVolume(nodesMap_); // 计算 Cell 的中心和体积
                cells_.push_back(cell);
            }
        }
        // 棱柱单元（type == 6）
        else if (!is2D && type == 6)
        {
            size_t numPrisms = elementTags[i].size();
            for (size_t j = 0; j < numPrisms; j++)
            {
                int cellId = static_cast<int>(elementTags[i][j]);
                vector<int> cellNodeIDs;
                for (int k = 0; k < 6; k++)  // 棱柱有 6 个节点
                    cellNodeIDs.push_back(static_cast<int>(nodeTagsPerElement[i][6 * j + k]));

                Cell cell(cellId, cellNodeIDs);
                cell.computeCenterAndVolume(nodesMap_);
                cells_.push_back(cell);
            }
        }
        // 六面体单元（type == 5）
        else if (!is2D && type == 5)
        {
            size_t numPrisms = elementTags[i].size();
            for (size_t j = 0; j < numPrisms; j++)
            {
                int cellId = static_cast<int>(elementTags[i][j]);
                vector<int> cellNodeIDs;
                for (int k = 0; k < 8; k++)  // 棱柱有 6 个节点
                    cellNodeIDs.push_back(static_cast<int>(nodeTagsPerElement[i][8 * j + k]));
                Cell cell(cellId, cellNodeIDs);
                cell.computeCenterAndVolume(nodesMap_);
                cells_.push_back(cell);
            }
        }
        else if (!is2D && type == 7)   // pyramid(5)（兼容读取）
        {         
            size_t n = elementTags[i].size();
            for (size_t j = 0; j < n; ++j) 
            {
                int cellId = static_cast<int>(elementTags[i][j]);
                std::vector<int> ids(5);
                for (int k = 0; k < 5; ++k) ids[k] = static_cast<int>(nodeTagsPerElement[i][5 * j + k]);
                Cell c(cellId, ids); c.computeCenterAndVolume(nodesMap_); cells_.push_back(c);
            }
        }
    }
    // 构建单元ID到索引的映射，方便后续快速访问
    cellId2index_.clear();
    for (size_t i = 0; i < cells_.size(); ++i)
    {
       // cout << "Cell ID: " << cells_[i].id << endl;	
		cellId2index_[cells_[i].id] = static_cast<int>(i); //局部编号到全局编号的映射
    }
    // 统计总单元数
    gridCount_ = cells_.size();
    std::cout << "网格数量为" << gridCount_ << endl;
    struct FaceAcc {
        std::vector<int> ordered;      // 有序顶点（来自某个单元的 getLocalFaces 原序）
        std::vector<int> cells;        // 邻接单元 id（1 或 2）
    };
    std::unordered_map<std::vector<int>, FaceAcc, VectorHash> FacetoCellMap;

    for (const auto& cell : cells_) {
        for (const auto& faceNodeIDs_ordered : cell.getLocalFaces(nodesMap_)) {
            std::vector<int> key = faceNodeIDs_ordered;
            std::sort(key.begin(), key.end());            // 只用于去重
            auto& acc = FacetoCellMap[key];
            if (acc.ordered.empty()) acc.ordered = faceNodeIDs_ordered; // 保存环序一次
            acc.cells.push_back(cell.id);
        }
    }
    // 2) 实例化：用“环序”构造几何；必要时校正朝向（可选）
    faces_.clear();
    int faceId = 1;
    for (auto& kv : FacetoCellMap) {
        const auto& orderedIDs = kv.second.ordered;   // 正确环序
        std::vector<Vector> nodeCoords; nodeCoords.reserve(orderedIDs.size());
        for (int nid : orderedIDs) nodeCoords.push_back(nodesMap_.at(nid).coord);

        Face face(faceId, orderedIDs, nodeCoords);    // 几何计算用环序
        face.ownerCell = kv.second.cells[0];
        face.neighborCell = (kv.second.cells.size() == 2) ? kv.second.cells[1] : -1;

        // 法向一致化：让法向从 owner 指向 neighbor 外侧
        if (face.neighborCell != -1) {
            const Vector& co = cells_[cellId2index_.at(face.ownerCell)].center;
            const Vector& cn = cells_[cellId2index_.at(face.neighborCell)].center;
            Vector n = face.normal;                   // Face 构造里算出的法向
            Vector d = cn - co;
            if ((n * d) > 0) {                        // 点乘>0 说明朝向进邻居，翻转
                std::vector<int> revIDs = orderedIDs;
                std::reverse(revIDs.begin(), revIDs.end());
                std::reverse(nodeCoords.begin(), nodeCoords.end());
                face = Face(faceId, revIDs, nodeCoords);
                face.ownerCell = kv.second.cells[0];
                face.neighborCell = kv.second.cells.size() == 2 ? kv.second.cells[1] : -1;
            }
        }
        faces_.push_back(face);
        for (int cid : kv.second.cells)
            cells_[cellId2index_.at(cid)].CellFaceIDs.push_back(faceId);
        ++faceId;
    }
	buildFaceBins(); // 构建面 bin
    gmsh::write("UnstructuredMesh-EDFM.msh");
    gmsh::finalize();
}
void Mesh::ClassifySolidMatrixCells()
{
    // 构造一个 faceId 到 Face 的映射
   
    for (auto& cell : cells_)
    {
        bool isBoundary = false;
        for (int faceId : cell.CellFaceIDs)
        {
            if (faces_[faceId - 1].neighborCell == -1)
            {
                isBoundary = true;
                break;
            }
        }
        cell.location = isBoundary ? Cell::LocationType::Boundary : Cell::LocationType::Inner;
    }
}

// =========== 计算 (ix,iy) -> 唯一 bin ID  =============
static inline int computeBinID(int ix, int iy, int binCountY)
{
    return ix * binCountY + iy;
}

void Mesh::buildFaceBins()
{
    if (faces_.empty()) return;

    // ---------- 1. 统计整个网格的坐标范围 ----------
    double minX = std::numeric_limits<double>::max();
    double minY = std::numeric_limits<double>::max();
    double maxX = -std::numeric_limits<double>::max();
    double maxY = -std::numeric_limits<double>::max();

    for (const auto& f : faces_) {
        minX = std::min(minX, f.boundingBox.min.m_x);
        minY = std::min(minY, f.boundingBox.min.m_y);
        maxX = std::max(maxX, f.boundingBox.max.m_x);
        maxY = std::max(maxY, f.boundingBox.max.m_y);
    }

    // ---------- 2. 自动计算 bin 数量 ----------
    int targetFacesPerBin = 70;  //可调范围在5-30，越小精度越高，越大过滤速度越快内存消耗越大
    int totalFaces = static_cast<int>(faces_.size());
    int totalBins = std::max(1, totalFaces / targetFacesPerBin);
    int sqrtBins = static_cast<int>(std::sqrt(totalBins));

    binCountX_ = std::min(std::max(sqrtBins, 10), 100); //clamp上下限 5-200 越小 粗网格测试
    binCountY_ = std::min(std::max(sqrtBins, 10), 100);

    binSizeX_ = (maxX - minX) / binCountX_;
    binSizeY_ = (maxY - minY) / binCountY_;

    // ---------- 3. 防护判断 ----------
    if (binSizeX_ <= 0 || binSizeY_ <= 0) {
        std::cerr << "[buildFaceBins] 检测到包围盒尺寸异常，终止构建\n";
        return;
    }

    faceBins_.clear();

    // ---------- 4. 遍历所有面，把它们放进对应 bin ----------
    for (const auto& f : faces_) {
        const AABB& box = f.boundingBox;

        int ix_min = static_cast<int>((box.min.m_x - minX) / binSizeX_);
        int iy_min = static_cast<int>((box.min.m_y - minY) / binSizeY_);
        int ix_max = static_cast<int>((box.max.m_x - minX) / binSizeX_);
        int iy_max = static_cast<int>((box.max.m_y - minY) / binSizeY_);

        ix_min = std::max(0, std::min(binCountX_ - 1, ix_min));
        iy_min = std::max(0, std::min(binCountY_ - 1, iy_min));
        ix_max = std::max(0, std::min(binCountX_ - 1, ix_max));
        iy_max = std::max(0, std::min(binCountY_ - 1, iy_max));

        for (int ix = ix_min; ix <= ix_max; ++ix)
            for (int iy = iy_min; iy <= iy_max; ++iy) {
                int binID = computeBinID(ix, iy, binCountY_);
                faceBins_[binID].push_back(f.id);
            }
    }

    // ---------- 5. 日志 ----------
    std::size_t filledBins = 0;
    for (const auto& kv : faceBins_) if (!kv.second.empty()) ++filledBins;

    std::cout << "[buildFaceBins] 总面数 = " << faces_.size()
        << ", Bin 划分 = " << binCountX_ << "×" << binCountY_
        << ", 平均每 bin 面数 ≈ "
        << static_cast<double>(faces_.size()) / std::max<std::size_t>(1, filledBins)
        << std::endl;
}


/*  ============================================================
 *  Mesh::getCandidateFacesFromBins — 根据查询盒子 (box)
 *  返回可能与之相交的网格面 ID 列表（去重后）。
 *  依赖：binCountX_ / binCountY_ / binSizeX_ / binSizeY_
 *        以及 buildFaceBins() 构建好的 faceBins_。
 *  ============================================================ */
std::vector<int> Mesh::getCandidateFacesFromBins(const AABB& box) const
{
    std::vector<int> result;
    if (faceBins_.empty()) return result;

    // ---------- 1. 全局坐标基准（minX, minY） ----------
    double minX = std::numeric_limits<double>::max();
    double minY = std::numeric_limits<double>::max();
    for (const auto& f : faces_) {
        minX = std::min(minX, f.boundingBox.min.m_x);
        minY = std::min(minY, f.boundingBox.min.m_y);
    }

    // ---------- 2. 计算 AABB 所落入的 bin 区间 ----------
    int ix_min = static_cast<int>((box.min.m_x - minX) / binSizeX_);
    int iy_min = static_cast<int>((box.min.m_y - minY) / binSizeY_);
    int ix_max = static_cast<int>((box.max.m_x - minX) / binSizeX_);
    int iy_max = static_cast<int>((box.max.m_y - minY) / binSizeY_);

    ix_min = std::max(0, std::min(binCountX_ - 1, ix_min));
    iy_min = std::max(0, std::min(binCountY_ - 1, iy_min));
    ix_max = std::max(0, std::min(binCountX_ - 1, ix_max));
    iy_max = std::max(0, std::min(binCountY_ - 1, iy_max));

    // ---------- 3. 预收集候选面 ID（未去重） ----------
    std::vector<int> rawList;
    for (int ix = ix_min; ix <= ix_max; ++ix)
        for (int iy = iy_min; iy <= iy_max; ++iy) {
            int binID = computeBinID(ix, iy, binCountY_);
            auto it = faceBins_.find(binID);
            if (it == faceBins_.end()) continue;
            rawList.insert(rawList.end(), it->second.begin(), it->second.end());
        }

    // ---------- 4. 去重 ----------
    std::sort(rawList.begin(), rawList.end());
    rawList.erase(std::unique(rawList.begin(), rawList.end()), rawList.end());

    // ---------- 5. 二次过滤：AABB overlap ----------
    result.reserve(rawList.size());
    for (int fid : rawList) {
        const Face& f = faces_[fid - 1];  // ID 从 1 开始
        if (f.boundingBox.min.m_x <= box.max.m_x && f.boundingBox.max.m_x >= box.min.m_x &&
            f.boundingBox.min.m_y <= box.max.m_y && f.boundingBox.max.m_y >= box.min.m_y) {
            result.push_back(fid);
        }
    }

    return result;
}

vector<std::reference_wrapper<const Cell>> Mesh::getInnerCells() const
{
    vector<std::reference_wrapper<const Cell>> innerCells;
    for (const auto& cell : cells_)
    {
        if (cell.location == Cell::LocationType::Inner)
            innerCells.push_back(std::cref(cell));
    }
    return innerCells;
}

vector<std::reference_wrapper<const Cell>> Mesh::getBoundaryCells() const
{
	vector<std::reference_wrapper<const Cell>> boundaryCells;
	for (const auto& cell : cells_)
	{
		if (cell.location == Cell::LocationType::Boundary)
			boundaryCells.push_back(std::cref(cell));
	}
	return boundaryCells;
}

void Mesh::printMeshInfo()
{
    std::cout << "总节点数: " << nodes_.size() << endl;
    std::cout << "总单元数: " << cells_.size() << endl;
    std::cout << "总面数: " << faces_.size() << endl;
    int nInner = 0, nBoundary = 0;
    for (const auto& cell : cells_) {
        if (cell.location == Cell::LocationType::Inner) ++nInner;
        else if (cell.location == Cell::LocationType::Boundary) ++nBoundary;
    }
    std::cout << "内部单元数: " << nInner << endl;
    std::cout << "边界单元数: " << nBoundary << endl;

    std::cout << "\n―― 节点信息 ――" << endl;
    for (const auto& node : nodes_)
    {
        std::cout << "Node " << node.id << " : ("
            << node.coord.m_x << ", " << node.coord.m_y << ", " << node.coord.m_z << ")"
            << endl;
    }
    std::cout << "\n―― 单元信息 ――" << endl;      //还需要添加Owner和Neighbor
    for (const auto& cell : cells_)
    {
        if (cell.id < 0) continue;   // 跳过ghost cell
        std::cout << "Cell " << cell.id << " 中心: ("
            << cell.center.m_x << ", " << cell.center.m_y << ", " << cell.center.m_z << ")"
            << " 面积: " << cell.volume << endl;
        std::cout << "  包含面: ";
        for (int fid : cell.CellFaceIDs)
            std::cout << fid << " ";
        std::cout << endl;
    }
    std::cout << "\n―― 面信息 ――" << endl;
    for (const auto& face :faces_)
    {
        std::cout << "Face " << face.id << " 节点: ";
        for (int nid : face.FaceNodeIDs)
            std::cout << nid << " ";
        std::cout << " | owner: " << face.ownerCell
            << " neighbor: " << face.neighborCell << endl;
        std::cout << "  中点: (" << face.midpoint.m_x << ", " << face.midpoint.m_y << ", " << face.midpoint.m_z
            << "), 边长: " << face.length << endl;
    }

}

double Mesh::getCellArea(int cellID) const
{
    // 根据 cellID 查找基岩单元，获取它的面积
    for (const auto& cell : cells_)
    {
        if (cell.id == cellID) 
        {
            return cell.volume;  
        }
    }
    return 0.0; // 如果找不到对应的单元，返回0
}

void Mesh::ComputeSolidMatrixMeshFaceGeometricInfor(NormalVectorCorrectionMethod method)
{
    for (auto& face : faces_)
    {
        // owner 下标
        auto it_o = cellId2index_.find(face.ownerCell);
        if (it_o == cellId2index_.end()) {
            // 安全：若异常则跳过
            continue;
        }
        const Vector& Cp = cells_[it_o->second].center;

        if (face.neighborCell >= 0)
        {
            // 内部面：用原有 owner+neighbor 的分解
            auto it_n = cellId2index_.find(face.neighborCell);
            if (it_n == cellId2index_.end()) {
                continue;
            }
            const Vector& Cn = cells_[it_n->second].center;
            face.computeFaceVectors(Cp, Cn, method);
        }
        else
        {
            // 边界面：无 ghost，调用新边界分解
            face.computeFaceVectorsBoundary(Cp, method);
        }
    }
}

void Mesh::exportToTxt(const std::string& prefix) const 
{
    // Nodes
    ofstream fn(prefix + "_nodes.txt");
    fn << "id x y z\n";
    for (auto& n : nodes_)
        fn << n.id << " "
        << n.coord.m_x << " "
        << n.coord.m_y << " "
        << n.coord.m_z << "\n";
    fn.close();

    // Faces
    ofstream ff(prefix + "_faces.txt");
    ff << "id n1 n2 mx my mz\n";
    for (auto& f : faces_) {
        ff << f.id << " "
            << f.FaceNodeIDs[0] << " "
            << f.FaceNodeIDs[1] << " "
            << f.midpoint.m_x << " "
            << f.midpoint.m_y << " "
            << f.midpoint.m_z << "\n";
    }
    ff.close();

    // Cells
    ofstream fc(prefix + "_cells.txt");
    fc << "id cx cy cz\n";
    for (auto& c : cells_) {
        fc << c.id << " "
            << c.center.m_x << " "
            << c.center.m_y << " "
            << c.center.m_z << "\n";
    }
    fc.close();
}

```

```C++
/// Node.h 具体代码实现
/*---------------------------------------------------------------------------*\
*                                 Node 数据类型
* 作用：    读取gmsh生成的网格节点，并存储节点编号和坐标信息。
* 
* 成员变量： 节点编号 （id）;  节点坐标（coord）
* 
* 构造
\*---------------------------------------------------------------------------*/
#pragma once
#include <vector>
#include <algorithm>
#include "UserDefineVarType.h"
using namespace std;

class Node 
{
public:
    int id;         // 节点编号
    Vector coord;   // 节点坐标
    Node(int id = -1, const Vector& coord = Vector(0.0, 0.0, 0.0)) : id(id), coord(coord) {}//构造函数及初始化列表 
};
```

```C++
/// Face.h 具体代码实现
#pragma once
#include <vector>
#include <cmath>
#include "UserDefineVarType.h"
#include "AABB.h"
using namespace std;

// ---------- 非正交校正方法枚举 ----------
enum class NormalVectorCorrectionMethod 
{
    MinimumCorrection,    // 最小修正值法（Minimum Correction Approach）
    OrthogonalCorrection, // 正交修正法（Orthogonal Correction Approach）
    OverRelaxed          // 超松弛修正法（Over-relaxed Approach）
};


class Face 
{
public:
    int id;                              // 面的编号
    vector<int> FaceNodeIDs;            // 构成该面节点的编号（2D 为2个，3D 为3个）
    vector<Vector> FaceNodeCoords;      // 构成面节点的坐标
    double length;                       // 面的长度（2D边长 or 3D面积）
    Vector normal;                       // 面的法向量（单位向量）
    Vector midpoint;                     // 面的几何中心
    int ownerCell;                       // 所属的单元编号
    int neighborCell;                    // 相邻的单元编号（无为 -1）
	AABB boundingBox;                   // 面的包围盒（用于碰撞检测等）

    Vector ownerToNeighbor;            // 从 ownerCell.center 指向 neighborCell.center 的向量
    Vector vectorE;                    // 分解得到的正交分量（沿 d 方向）
    Vector vectorT;                    // 分解得到的非正交分量
    double faceDiscreCoef = 0.0;       // 面的离散化系数 a_face
    double faceSource = 0.0;        // 面的源项

    // —— 下面这些字段用于压力插值和梯度（待修正） ——  
    Vector f_pressureGrad;             // 面上压力梯度
    double f_linearInterpolationCoef;  // 插值权重（φ_face = coef·φ_owner + …）
    double f_pressureValue;            // 面上压力值 φ_face

    Face(int id, const vector<int>& nodeIDs, const vector<Vector>& nodeCoords);
    bool isBoundary() const { return neighborCell == -1; } //判断自己是否属于边界面

    // ---------- 在 owner/neighbor 重心已知时，分解 A_j = E_j + T_j ----------
/**
 * @param Cp      ownerCell 的重心坐标
 * @param Cn      neighborCell 的重心坐标
 * @param method  选择三种校正策略之一
 */
    void computeFaceVectors
    (
        const Vector& Cp,
        const Vector& Cn,
        NormalVectorCorrectionMethod method = NormalVectorCorrectionMethod::MinimumCorrection
    );

    void computeFaceVectorsBoundary(
        const Vector& Cp,
        NormalVectorCorrectionMethod method = NormalVectorCorrectionMethod::OrthogonalCorrection
    );
private:
    void computeGeometry();  // 根据维度自动计算几何属性（中点、法向量、长度或面积）
};

///Face.cpp
#include "Face.h"
#include "UserDefineVarType.h"

Face::Face(int id, const std::vector<int>& nodeIDs, const std::vector<Vector>& nodeCoords)
    : id(id), FaceNodeIDs(nodeIDs), FaceNodeCoords(nodeCoords), length(0.0), ownerCell(-1), neighborCell(-1)
{
    computeGeometry();
}

void Face::computeGeometry()
{
    size_t n = FaceNodeCoords.size(); //记录节点数量
    if (n == 2) 
    {
        // 2D 面（线段）
        midpoint = (FaceNodeCoords[0] + FaceNodeCoords[1]) / 2.0;
        Vector diff = FaceNodeCoords[1] - FaceNodeCoords[0];
        length = diff.Mag();
		//cout << "Face " << id << " 2D 面长度: " << length << endl;
        normal = Vector(diff.m_y, -diff.m_x, 0.0);
		//cout << "Face " << id << " 2D 面法向量: ("
			//<< normal.m_x << ", " << normal.m_y << ", " << normal.m_z << ")" << endl;
        double normMag = normal.Mag();
        if (normMag > 1e-12)
			normal = normal / normMag; // 单位化法向量

        if (!FaceNodeCoords.empty())
        {
			// 计算包围盒
			Vector minCoord = FaceNodeCoords[0];
			Vector maxCoord = FaceNodeCoords[0];
			for (const auto& coord : FaceNodeCoords)
			{
				if (coord.m_x < minCoord.m_x) minCoord.m_x = coord.m_x;
				if (coord.m_y < minCoord.m_y) minCoord.m_y = coord.m_y;
				if (coord.m_z < minCoord.m_z) minCoord.m_z = coord.m_z;
				if (coord.m_x > maxCoord.m_x) maxCoord.m_x = coord.m_x;
				if (coord.m_y > maxCoord.m_y) maxCoord.m_y = coord.m_y;
				if (coord.m_z > maxCoord.m_z) maxCoord.m_z = coord.m_z;
			}
			boundingBox = AABB(minCoord, maxCoord);
        }

    }
    else if (n == 3)
    {
        // 3D 面（三角形面片）
        const Vector& p0 = FaceNodeCoords[0];
        const Vector& p1 = FaceNodeCoords[1];
        const Vector& p2 = FaceNodeCoords[2];

        // 面的几何中心（三角形重心）
        midpoint = (p0 + p1 + p2) / 3.0;

        // 计算法向量：normal = (p1 - p0) × (p2 - p0)
        Vector v1 = p1 - p0;
        Vector v2 = p2 - p0;
        normal = v1 & v2;  // 使用已重载的叉乘运算符 &
        double area = 0.5 * normal.Mag(); // 面积为叉积长度的一半
        length = area; // 3D 中将面积赋值给 length（可改为 area 字段）

        // 单位化法向量
        if (normal.Mag() > 1e-12)
            normal = normal / normal.Mag();
    }
}

void Face::computeFaceVectors(const Vector& Cp, const Vector& Cn, NormalVectorCorrectionMethod method)
{
    // 1) 计算从 owner 到 neighbor 的向量 d
    ownerToNeighbor = Cn - Cp;
    double d_norm = ownerToNeighbor.Mag();
    if (d_norm < 1e-12) 
    {
        // 重心重合或太近，直接置零
        vectorE = Vector(0.0, 0.0, 0.0);
        vectorT = Vector(0.0, 0.0, 0.0);
        return;
    }
    Vector ej = ownerToNeighbor / d_norm;  // 单位方向向量
    //cout << "Face " << id << " 的单位方向向量 e_j: ("
    //    << ej.m_x << ", " << ej.m_y << ", " << ej.m_z << ")  "
    //    << endl;

    // 2) 构造面积矢量 A_j = normal * length
    Vector Aj = normal * length;
    double Aj_dot_ej = Aj * ej;  // 点积
    
    if ((Aj * ej) < 0)
    {
		Aj = -Aj; //		// 确保法向量与单位向量同向
        Aj_dot_ej = -Aj_dot_ej;
    }
    // —— 关键容错：近正交（Aj·ej≈0）时的保护 —— 
    const double eps = 1e-14;   // 可按你的坐标尺度调整
    if (Aj_dot_ej < eps) Aj_dot_ej = eps;

    // 3) 依据不同算法分解 A_j = E_j + T_j
    switch (method) 
    {
    case NormalVectorCorrectionMethod::MinimumCorrection:
        // E_j = (A_j·e_j) e_j
        vectorE = ej * Aj_dot_ej;
        //cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;

        break;

    case NormalVectorCorrectionMethod::OrthogonalCorrection:
        // E_j = |A_j| e_j, 其中 |A_j| = length (normal 已单位化)
        vectorE = ej * length;
       // cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;
        break;

    case NormalVectorCorrectionMethod::OverRelaxed:
    {
        // E_j = |A_j|^2 / (A_j·e_j) * e_j
        double Aj_norm = length;
        double factor = (Aj_norm * Aj_norm) / Aj_dot_ej;
        vectorE = ej * factor;
        //cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;
        break;
    }
    }
    // 4) 非正交分量
    vectorT = Aj - vectorE;
   // cout << "Face :" << id << "的T矢量:(" << vectorT.m_x << ", " << vectorT.m_y << ", " << vectorT.m_z << ")" << endl;
    //5） 正交插值权重gamma 投影到 e_j（0..1 之间）
    double D = ownerToNeighbor * ej;     // 应等于 d_norm
    //cout << "Face " << id << "D: " << D << endl;
    //cout << "Face " << id << "d_norm: " << d_norm << endl;
    double s = (midpoint - Cp) * ej;     // owner 到 面心 在 e_j 上的投影
    double gamma = (std::abs(D) > 1e-14) ? (s / D) : 0.5; // 容错
    if (gamma < 0.0) gamma = 0.0;
    if (gamma > 1.0) gamma = 1.0;
    f_linearInterpolationCoef = gamma;

}


/**
 * @brief 处理边界面时的分解 A_j = E_j + T_j
 *
 * @param Cp      ownerCell 的重心坐标
 * @param method  选择三种校正策略之一（目前未使用）
 * 边界面没邻居中心坐标 Cn，但做 E/T 分解只需面法向和模长即可
 * 用 rPF 保证 normal 始终朝外，避免节点序反向导致的“内法向”。
 */
void Face::computeFaceVectorsBoundary(const Vector& Cp,
    NormalVectorCorrectionMethod /*method*/)
{
    // 1) 依据 owner中心 -> 面心 的向量与当前 normal 的夹角，修正法向指向外侧
    Vector rPF = midpoint - Cp;
    double sgn = (normal * rPF) >= 0.0 ? 1.0 : -1.0;

    // ↓↓↓ 把外指法向写回，并确保为单位向量 ↓↓↓
    normal = normal * sgn;
    double nmag2 = normal.m_x * normal.m_x + normal.m_y * normal.m_y + normal.m_z * normal.m_z;
    if (nmag2 > 0.0) {
        double invn = 1.0 / std::sqrt(nmag2);
        normal = normal * invn;
    }

    // 2) 面积矢量 A = |A| * n_hat；2D 情况下 |A| = 边长 length（3D 为面积）
    Vector Aj = normal * length;

    // 3) 边界面分解
    vectorE = Aj;
    vectorT = Vector(0.0, 0.0, 0.0);

    // 4) owner→外部 的方向（与 normal 一致）
    ownerToNeighbor = rPF;
    f_linearInterpolationCoef = 1.0;
}
```

```C++
/// Cell.h具体代码实现
#include "Cell.h"
#include <cmath>

Cell::Cell(int id, const std::vector<int>& nodeIDs)
	: id(id), CellNodeIDs(nodeIDs), volume(0.0), center(0.0, 0.0, 0.0), sourceTerm(0.0), faceDiscreCoef(0.0), /*pressure(6.531e7), pressureGradient(0.0, 0.0, 0.0), temperature(597.65), saturation_water(0.8), saturation_CO2(0.2),*/ error(1e-6) // 初始化物性参数
{
    // 物性参数通过 materialProps 成员进行初始化
}

vector<vector<int>> Cell::getLocalFaces(const std::unordered_map<int, Node>& allNodes) const
{
    const auto& cn = CellNodeIDs;
    std::vector<std::vector<int>> faces;

    auto is2DCell = [&](double eps = 1e-12)->bool
    {
        double zmin = 1e300, zmax = -1e300;
        for (int nid : cn) {
            const Vector& p = allNodes.at(nid).coord;
            zmin = std::min(zmin, p.m_z);
            zmax = std::max(zmax, p.m_z);
        }
        return (zmax - zmin) < eps; 
    };
    // 2D：边（按环连接）
    if ((cn.size() == 3 || cn.size() == 4) && is2DCell()) {
        const int m = static_cast<int>(cn.size());
        faces.reserve(m);
        for (int i = 0; i < m; ++i) {
            int j = (i + 1) % m;
            faces.push_back({ cn[i], cn[j] });
        }
        return faces;
    }

    // 3D：典型单元
    if (cn.size() == 4) 
    { // tetra
        faces = {
            {cn[0], cn[1], cn[2]},
            {cn[0], cn[1], cn[3]},
            {cn[1], cn[2], cn[3]},
            {cn[0], cn[2], cn[3]}
        };
    }
    else if (cn.size() == 5)
    { // pyramid
        faces = {
            {cn[0], cn[1], cn[2], cn[3]},
            {cn[0], cn[1], cn[4]},
            {cn[1], cn[2], cn[4]},
            {cn[2], cn[3], cn[4]},
            {cn[3], cn[0], cn[4]}
        };
    }
    else if (cn.size() == 6) 
    { // prism
        faces = {
            {cn[0], cn[1], cn[2]},
            {cn[3], cn[4], cn[5]},
            {cn[0], cn[1], cn[4], cn[3]},
            {cn[1], cn[2], cn[5], cn[4]},
            {cn[2], cn[0], cn[3], cn[5]}
        };
    }
    else if (cn.size() == 8) 
    { // hexa
        faces = 
        {
            {cn[0], cn[1], cn[2], cn[3]},
            {cn[4], cn[5], cn[6], cn[7]},
            {cn[0], cn[1], cn[5], cn[4]},
            {cn[1], cn[2], cn[6], cn[5]},
            {cn[2], cn[3], cn[7], cn[6]},
            {cn[3], cn[0], cn[4], cn[7]}
        };
    }
    return faces;
}
void Cell::computeCenterAndVolume(const std::unordered_map<int, Node>& allNodes)
{
    const auto& cn = CellNodeIDs;
    auto polygonAreaCentroid2D = [&](const std::vector<int>& ids, double& A, Vector& C)
        {
            // 2D 多边形（按顺/逆时针）面积与质心，忽略 z
            const size_t n = ids.size();
            double area2 = 0.0, Cx = 0.0, Cy = 0.0;
            double zavg = 0.0;
            for (size_t i = 0; i < n; ++i) {
                const Vector& Pi = allNodes.at(ids[i]).coord;
                const Vector& Pj = allNodes.at(ids[(i + 1) % n]).coord;
                const double cross = Pi.m_x * Pj.m_y - Pj.m_x * Pi.m_y;
                area2 += cross;
                Cx += (Pi.m_x + Pj.m_x) * cross;
                Cy += (Pi.m_y + Pj.m_y) * cross;
                zavg += Pi.m_z;
            }
            double A_signed = 0.5 * area2;     // 可正可负
            A = std::fabs(A_signed);
            if (std::fabs(A_signed) < 1e-30) { C = Vector(0, 0, 0); return; }
            const double inv = 1.0 / (6.0 * A_signed);
            C = Vector(Cx * inv, Cy * inv, zavg / n); // z 取顶点平均
        };

    auto is2D = [&]() 
    {
        double zmin = 1e300, zmax = -1e300;
        for (int nid : cn) {
            const double z = allNodes.at(nid).coord.m_z;
            zmin = std::min(zmin, z);
            zmax = std::max(zmax, z);
        }
        return (zmax - zmin) < 1e-12;
    };

    // ---------- 2D：三角/四边形（面积与质心） ----------
    if (is2D() && (cn.size() == 3 || cn.size() == 4))
    {
        double A = 0.0; Vector C(0, 0, 0);
        polygonAreaCentroid2D(cn, A, C);
        center = C;
        volume = A; // 2D 用面积作为 "volume"
        return;
    }
    // ---------- 3D：典型单元 ----------
    if (cn.size() == 4) {
        // 四面体：混合积
        const Vector& p0 = allNodes.at(cn[0]).coord;
        const Vector& p1 = allNodes.at(cn[1]).coord;
        const Vector& p2 = allNodes.at(cn[2]).coord;
        const Vector& p3 = allNodes.at(cn[3]).coord;
        center = (p0 + p1 + p2 + p3) / 4.0;
        Vector v1 = p0 - p3, v2 = p1 - p3, v3 = p2 - p3;
        volume = std::fabs((v1 & v2) * v3) / 6.0; // & 叉乘，* 点乘
        return;
    }
    else if (cn.size() == 5) {
        // 金字塔：底面四边形 + 顶点（默认 cn[4] 为 apex）
        std::vector<int> base = { cn[0], cn[1], cn[2], cn[3] };
        const Vector& apex = allNodes.at(cn[4]).coord;

        double A = 0.0; Vector Cb(0, 0, 0);
        polygonAreaCentroid2D(base, A, Cb);

        double zbase = 0.0; for (int id : base) zbase += allNodes.at(id).coord.m_z; zbase /= 4.0;
        double h = apex.m_z - zbase; // 与 z 轴一致的挤出假设

        volume = (A * std::fabs(h)) / 3.0;
        center = Vector(Cb.m_x, Cb.m_y, (zbase + apex.m_z * 1.0) / 2.0); // 近似：介于1/4~1/2处；若需精确：z = zbase + h*1/4
        center.m_z = zbase + h * 0.25; // 精确：金字塔质心距底面 1/4 高
        return;
    }
    else if (cn.size() == 6) {
        // 棱柱：底三角(0,1,2) + 顶三角(3,4,5)，来自直线挤出
        std::vector<int> bot = { cn[0], cn[1], cn[2] };
        std::vector<int> top = { cn[3], cn[4], cn[5] };
        double Ab = 0.0; Vector Cb(0, 0, 0);
        polygonAreaCentroid2D(bot, Ab, Cb);
        double h = 0.0;
        h += allNodes.at(cn[3]).coord.m_z - allNodes.at(cn[0]).coord.m_z;
        h += allNodes.at(cn[4]).coord.m_z - allNodes.at(cn[1]).coord.m_z;
        h += allNodes.at(cn[5]).coord.m_z - allNodes.at(cn[2]).coord.m_z;
        h /= 3.0;
        volume = Ab * std::fabs(h);
        center = Vector(Cb.m_x, Cb.m_y, Cb.m_z + h * 0.5);
        return;
    }
    else if (cn.size() == 8) {
        // 六面体：底四边形(0..3) + 顶(4..7)，来自直线挤出
        std::vector<int> bot = { cn[0], cn[1], cn[2], cn[3] };
        double Ab = 0.0; Vector Cb(0, 0, 0);
        polygonAreaCentroid2D(bot, Ab, Cb);
        double h = 0.0;
        h += allNodes.at(cn[4]).coord.m_z - allNodes.at(cn[0]).coord.m_z;
        h += allNodes.at(cn[5]).coord.m_z - allNodes.at(cn[1]).coord.m_z;
        h += allNodes.at(cn[6]).coord.m_z - allNodes.at(cn[2]).coord.m_z;
        h += allNodes.at(cn[7]).coord.m_z - allNodes.at(cn[3]).coord.m_z;
        h /= 4.0;
        volume = Ab * std::fabs(h);
        center = Vector(Cb.m_x, Cb.m_y, Cb.m_z + h * 0.5);
        return;
    }

    // 若有其它多面体类型，建议用“通用多面体体积/质心”算法（基于三角面拼合），此处略。
    std::cerr << "不支持的单元类型，无法计算几何中心和体积/面积。 (nodes=" << cn.size() << ")\n";
        
}
```
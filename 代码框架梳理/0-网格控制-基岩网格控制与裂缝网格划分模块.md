```c++
//MeshManager.h
#pragma once
#include "Mesh.h"
#include "FractureNetwork.h"
#include "BoundaryFaceClassify.h"

/**
 * @class MeshManager
 * @brief 统一管理基岩 & 裂缝网格及几何CI计算
 */

class MeshManager
{
public:
    /**
     * @brief 构造函数
     * @param lx 区域长度 X
     * @param ly 区域长度 Y
     * @param lz 区域长度 Z（0 表示纯二维）
     * @param nx X 方向划分份数
     * @param ny Y 方向划分份数
     * @param nz Z 方向划分份数
     * @param usePrism 是否使用棱柱单元（true）或四面体（false）
     * @param useQuadBase 棱柱底面保留四边形（true）或分割为三角形（false）
     */
    MeshManager(double lx, double ly, double lz, int nx, int ny, int nz, bool usePrism, bool useQuadBase); //默认有参构造函数

    // —— 网格构建 & 预处理 ——————————————————————————————————
    void BuildSolidMatrixGrid(NormalVectorCorrectionMethod corr = NormalVectorCorrectionMethod::OrthogonalCorrection);


    // —— 裂缝几何 & CI 计算 —————————————————————————————
    /// 添加裂缝（起点→终点）
    void addFracture(const Vector& start, const Vector& end); //手动插入裂缝用于调试

    //DFN裂缝模型
    void setDFNRandomSeed(unsigned seed);  // 设置随机种子
    void generateDFN(int N,
        const Vector& minPoint,
        const Vector& maxPoint,
        double Lmin,
        double Lmax,
        double alpha,
        double kappa,
        bool avoidOverlap); //生成随机裂缝网络

    /// 处理裂缝几何：交点→排序→subdivide
    void DetectAndSubdivideFractures(bool useAABBAccelerationctrl);
    void setDistanceMetric(DistanceMetric m) { distanceMetric_ = m; }
    DistanceMetric distanceMetric() const { return distanceMetric_; }

    /// 只算几何耦合（调用 computeGeometryCoupling）
    void ComputeFractureGeometryCouplingCoefficient();

    ///访问边界面
    const BoundaryFaceClassify::FaceGroups& boundaryFaces() const { return bcGroups_; }
    // 统计所有边界面总数（自检用）
    size_t countBoundaryFaces() const { return boundaryCount_; }

    // —— 输出 & 调试 ——————————————————————————————————
    void exportMesh(const std::string& prefix) const;
    void exportFractures(const std::string& prefix) const;
    void printFractureInfo() const;
    void printCISourceTerms();

    // —— 访问底层 Mesh & FractureNetwork ——————————————————
    Mesh& mesh() { return mesh_; }
    FractureNetwork& fracture_network() { return frNet_; }

private:
    Mesh mesh_; // 网格成员对象
    FractureNetwork frNet_; // 裂缝网络成员对象
    double lx_, ly_, lz_; // 区域长度成员对象
    int nx_, ny_, nz_; // 网格数量成员对象
    bool usePrism_, useQuadBase_; // 网格单元类型成员对象
    DistanceMetric distanceMetric_ = DistanceMetric::AreaWeight;
    BoundaryFaceClassify::FaceGroups bcGroups_;
    size_t boundaryCount_ = 0;

};
```

```c++
//MeshManager.cpp
#pragma once
#include "Mesh.h"
#include "MeshManager.h"
#include "FractureNetwork.h"

MeshManager::MeshManager(double lx, double ly, double lz,
    int nx, int ny, int nz,
    bool usePrism, bool useQuadBase)
    : lx_(lx), ly_(ly), lz_(lz),
    nx_(nx), ny_(ny), nz_(nz),
    usePrism_(usePrism), useQuadBase_(useQuadBase)
{
    cout<<"调用MeshManager构造函数并初始化"<< "\n";
}

void MeshManager::BuildSolidMatrixGrid(NormalVectorCorrectionMethod corr) 
{
    mesh_.BuildMesh(lx_, ly_, lz_, nx_, ny_, nz_, usePrism_, useQuadBase_);
    mesh_.ClassifySolidMatrixCells();       //用于区分内部单元和边界单元
    bcGroups_ = BoundaryFaceClassify::ClassifyBoundaryFaces(mesh_, lx_, ly_,lz_,1e-9);
    // 2) 可选：统计所有边界面（用于自检）
    boundaryCount_ = 0;
    for (const auto& f : mesh_.getFaces()) if (f.isBoundary()) ++boundaryCount_;
    // 3) （可选）自检打印
    std::cout << "[BC] faces: x0=" << bcGroups_.x0.size()
        << " xL=" << bcGroups_.xL.size()
        << " y0=" << bcGroups_.y0.size()
        << " yL=" << bcGroups_.yL.size()
        << " z0=" << bcGroups_.z0.size()
        << " zL=" << bcGroups_.zL.size()
        << " | total boundary=" << boundaryCount_ << "\n";

    mesh_.ComputeSolidMatrixMeshFaceGeometricInfor(corr);
}

void MeshManager::addFracture(const Vector& s, const Vector& e) 
{
    frNet_.addFracture(s, e);
}

void MeshManager::DetectAndSubdivideFractures(bool useAABBAccelerationctrl = false)
{
    frNet_.invalidateFracElemIndex();

    // 1) 先找裂缝–裂缝的交点
    frNet_.DetectFracturetoFractureIntersections();
    
    bool useAABBAcceleration = useAABBAccelerationctrl;  // 或 false 用于对比测试
    int totalFaces = mesh_.getFaces().size();
    int totalCandidates = 0;

	// 2) 然后找裂缝–网格面的交点  可以选取AABB加速算法
    for (auto& F : frNet_.fractures)
    {
		if (useAABBAcceleration)
		{
			F.computeAABB(); // 计算每条裂缝的 AABB 边界框
			F.DetectFracturetoMeshFaceIntersections(mesh_, mesh_.getCells(), mesh_.getNodesMap(), true);
            totalCandidates += F.candidateFaceCount_; // 候选面数
		}
        else
        {
            F.DetectFracturetoMeshFaceIntersections(mesh_, mesh_.getCells(), mesh_.getNodesMap(), false);
            totalCandidates += totalFaces; // 所有面都遍历
        }

    }
    std::cout << "[加速效果] 总面数 = " << totalFaces
        << ", 总裂缝数 = " << frNet_.fractures.size()
        << ", 总候选面数 = " << totalCandidates
        << ", 平均每条裂缝面数 = " << (double)totalCandidates / frNet_.fractures.size()
        << ", 剔除率 = " << (100.0 - 100.0 * totalCandidates / (totalFaces * frNet_.fractures.size()))
        << "%\n";

    // 3) 给全局裂缝–裂缝交点去重并编号
    frNet_.DeduplicateAndRenumberFractureToFractureIntersections();
    
    // 4) 把全局裂缝–裂缝交点也插入到每条裂缝的 intersections 中
    frNet_.DistributeFracture_FractureIntersectionsToGlobalInersections();

    // 5) 重新排序 & 编号，然后划分
    for (auto& F : frNet_.fractures)
    {
        F.sortAndRenumberIntersections();
        F.subdivide(mesh_.getCells(), mesh_.getNodesMap(), distanceMetric_);
    }
	frNet_.rebuildFracElemIndex(); // 重建裂缝段索引
	frNet_.printFractureInfo();
}


void MeshManager::ComputeFractureGeometryCouplingCoefficient()
{
    for (auto& F : frNet_.fractures)
        F.computeGeometryCouplingCoefficientgeomCIandgeomAlpha();
}

void MeshManager::setDFNRandomSeed(unsigned seed)
{
	frNet_.setRandomSeed(seed);
}

void MeshManager::generateDFN(int N,
    const Vector& minPoint,
    const Vector& maxPoint,
    double Lmin,
    double Lmax,
    double alpha,
    double kappa,
    bool avoidOverlap)
{
	frNet_.generateDFN(N, minPoint, maxPoint, Lmin, Lmax, alpha, kappa, avoidOverlap);
}

void MeshManager::exportMesh(const std::string& pref) const {
    mesh_.exportToTxt(pref);
}

void MeshManager::exportFractures(const std::string& pref) const {
    frNet_.exportToTxt(pref);
}

void MeshManager::printFractureInfo() const {
    frNet_.printFractureInfo();
}

void MeshManager::printCISourceTerms()  
{
    std::cout << "\n=== 检查基岩–裂缝 CI 源项 ===\n";
    for (auto& cell : mesh_.getCells())
    {
        if (cell.id < 0) continue;               // 跳过 Ghost
        if (cell.CI.empty())     continue;       // 没有 fracture 交互就跳过

        std::cout << "Cell " << cell.id << ":\n";
        for (size_t k = 0; k < cell.CI.size(); ++k) {
            std::cout
                << "  SegID=" << cell.CI_belongFraction[k]
                << "  CI=" << cell.CI[k]
                << "  p_fr(cell)=" << cell.fracturePressure[k]
                << "\n";
        }
    }
}

```

```C++
//BoundaryFaceClassify.h
#pragma once
#pragma once
#include <vector>
#include <limits>
#include <cmath>
#include <algorithm>
#include "Mesh.h"  

namespace BoundaryFaceClassify
{
    // ---------------------------- 结果类型 ----------------------------
// 统一 2D/3D 的六面分组（2D 时 z0/zL 为空）
    struct FaceGroups
    {
        std::vector<int> x0, xL;  // x=0 / x=Lx
        std::vector<int> y0, yL;  // y=0 / y=Ly
        std::vector<int> z0, zL;  // z=0 / z=Lz（Lz<=0 时为空）
    };

    // ---------------------------- 小工具 ----------------------------
    inline bool nearAbs(double v, double tgt, double tolAbs) noexcept
    {
        return std::abs(v - tgt) < tolAbs;
    }

    // 按几何尺度把相对容差转成绝对容差；L<=0 时给一个保底尺度
    inline double makeAbsTol(double L, double tolRel) noexcept
    {
        const double scale = (L > 0.0 ? L : 1.0);
        return std::max(1e-14, tolRel * scale);
    }

    // 收集“真边界面” id（Face::isBoundary()==true）
    inline std::vector<int> getBoundaryFaceIDs(const Mesh& mesh) {
        std::vector<int> ids;
        const auto& faces = mesh.getFaces();
        ids.reserve(faces.size() / 4u + 8u);
        for (const auto& f : faces) {
            if (f.isBoundary()) ids.push_back(f.id); // 约定 id 为 1-based
        }
        return ids;
    }

    // 从 Face.FaceNodeCoords 计算各轴向 min/max（不依赖节点表索引）
    inline void faceMinMaxXYZ_fromFace(const Face& f,
        double& xmin, double& xmax,
        double& ymin, double& ymax,
        double& zmin, double& zmax)
    {
        xmin = ymin = zmin = std::numeric_limits<double>::infinity();
        xmax = ymax = zmax = -std::numeric_limits<double>::infinity();

        // FaceNodeCoords: std::vector<Vector>（2D:2个点；3D:3或4个点）
        for (const Vector& p : f.FaceNodeCoords) {
            xmin = std::min(xmin, p.m_x); xmax = std::max(xmax, p.m_x);
            ymin = std::min(ymin, p.m_y); ymax = std::max(ymax, p.m_y);
            zmin = std::min(zmin, p.m_z); zmax = std::max(zmax, p.m_z);
        }
    }

    // 判定“整张面”是否位于 x/y/z = 常数 的坐标平面（min/max 同时贴近）
    inline bool faceOnPlaneX(const Face& f, double xplane, double tolAbs)
    {
        double xmin, xmax, ymin, ymax, zmin, zmax;
        faceMinMaxXYZ_fromFace(f, xmin, xmax, ymin, ymax, zmin, zmax);
        return nearAbs(xmin, xplane, tolAbs) && nearAbs(xmax, xplane, tolAbs);
    }
    inline bool faceOnPlaneY(const Face& f, double yplane, double tolAbs)
    {
        double xmin, xmax, ymin, ymax, zmin, zmax;
        faceMinMaxXYZ_fromFace(f, xmin, xmax, ymin, ymax, zmin, zmax);
        return nearAbs(ymin, yplane, tolAbs) && nearAbs(ymax, yplane, tolAbs);
    }
    inline bool faceOnPlaneZ(const Face& f, double zplane, double tolAbs)
    {
        double xmin, xmax, ymin, ymax, zmin, zmax;
        faceMinMaxXYZ_fromFace(f, xmin, xmax, ymin, ymax, zmin, zmax);
        return nearAbs(zmin, zplane, tolAbs) && nearAbs(zmax, zplane, tolAbs);
    }
    // ---------------------------- 主功能：六面分类（2D/3D统一） ----------------------------
/**
 * @brief 把所有“真边界面”按几何位置分到 x0/xL, y0/yL, z0/zL 六类。
 *        若某面同时落在多个平面（角/棱），按法向主导轴唯一分派。
 *
 * @param Lx,Ly,Lz  物理域尺寸；2D 情况传 Lz<=0 即可
 * @param tolRel    相对容差（建议 1e-9 ~ 1e-8）
 */
    inline FaceGroups ClassifyBoundaryFaces(
        const Mesh& mesh,
        double Lx, double Ly, double Lz,
        double tolRel = 1e-9)
    {
        FaceGroups groups;

        const double tolX = makeAbsTol(Lx, tolRel);
        const double tolY = makeAbsTol(Ly, tolRel);
        const double tolZ = makeAbsTol(Lz, tolRel);

        for (const auto& f : mesh.getFaces())
        {
            if (!f.isBoundary()) continue;

            // 是否整体落在某个坐标平面
            const bool onX0 = faceOnPlaneX(f, 0.0, tolX);
            const bool onXL = faceOnPlaneX(f, Lx, tolX);
            const bool onY0 = faceOnPlaneY(f, 0.0, tolY);
            const bool onYL = faceOnPlaneY(f, Ly, tolY);
            const bool onZ0 = (Lz > 0.0) ? faceOnPlaneZ(f, 0.0, tolZ) : false;
            const bool onZL = (Lz > 0.0) ? faceOnPlaneZ(f, Lz, tolZ) : false;

            if (!(onX0 || onXL || onY0 || onYL || onZ0 || onZL)) continue;

            // 角/棱的唯一分派：选择法向绝对值最大的轴
            const double ax = std::abs(f.normal.m_x);
            const double ay = std::abs(f.normal.m_y);
            const double az = std::abs(f.normal.m_z);
            const int fid = f.id;

            if (ax >= ay && ax >= az) {
                if (onX0) groups.x0.push_back(fid);
                else if (onXL) groups.xL.push_back(fid);
                else if (onY0) groups.y0.push_back(fid);
                else if (onYL) groups.yL.push_back(fid);
                else if (onZ0) groups.z0.push_back(fid);
                else if (onZL) groups.zL.push_back(fid);
            }
            else if (ay >= ax && ay >= az) {
                if (onY0) groups.y0.push_back(fid);
                else if (onYL) groups.yL.push_back(fid);
                else if (onX0) groups.x0.push_back(fid);
                else if (onXL) groups.xL.push_back(fid);
                else if (onZ0) groups.z0.push_back(fid);
                else if (onZL) groups.zL.push_back(fid);
            }
            else {
                if (onZ0) groups.z0.push_back(fid);
                else if (onZL) groups.zL.push_back(fid);
                else if (onX0) groups.x0.push_back(fid);
                else if (onXL) groups.xL.push_back(fid);
                else if (onY0) groups.y0.push_back(fid);
                else if (onYL) groups.yL.push_back(fid);
            }
        }
        return groups;
    }

    // 便捷重载：2D 情况（内部把 Lz 置 0）
    inline FaceGroups ClassifyBoundaryFaces(
        const Mesh& mesh,
        double Lx, double Ly,
        double tolRel = 1e-9)
    {
        return ClassifyBoundaryFaces(mesh, Lx, Ly, /*Lz=*/0.0, tolRel);
    }


}

```

```C++
//FractureNetwork.h
#pragma once
#include <vector>
#include <map>
#include <set>
#include <iostream>
#include <unordered_map>
#include <cstdlib>   // rand, srand
#include <ctime>     // time
#include <cmath>     // cos, sin, M_PI
#include "FracIndex.h" 
#include "Fracture.h"

class FractureNetwork 
{
   
public:

    //储存裂缝与裂缝交点的信息
    struct GlobalFFPoint
    {
        int id;               // 全局编号
        Vector point;         // 交点坐标
        int fracA, fracB;     // 发生交点的两条裂缝索引
        double paramA, paramB;// 在线段 [0,1] 上的归一化位置
    };

	vector<Fracture> fractures;  // 裂缝集合
	vector<GlobalFFPoint> globalFFPts; // 裂缝-裂缝交点
   
    // ---- Cached fracture-element index ----
    inline void invalidateFracElemIndex()
    {
        fracElemIndexValid_ = false;
        fracElemIndex_.offset.clear();
        fracElemIndex_.total = 0;
    }

    inline void rebuildFracElemIndex()
    {
        fracElemIndex_ = buildFracElemIndex(*this); // 复用你现成函数
        fracElemIndexValid_ = true;
    }

    inline bool hasValidFracElemIndex() const { return fracElemIndexValid_; }

    inline const FracElemIndex& fracElemIndexFast() const
    {
        if (!fracElemIndexValid_) {
            std::cerr << "[FractureNetwork] FracElemIndex invalid. Call rebuildFracElemIndex() first.\n";
        }
        return fracElemIndex_;
    }

    void setRandomSeed(unsigned seed);  //unsigned 是什么数据类型？

    //@brief 生成随机 DFN 裂缝网络
    /**
     * @brief 基于 DFN 方法随机生成裂缝
     * @param N            要生成的裂缝数量
     * @param minPoint     裂缝中心坐标下限 (x,y,z)
     * @param maxPoint     裂缝中心坐标上限 (x,y,z)
     * @param Lmin         裂缝最小长度
     * @param Lmax         裂缝最大长度
     * @param alpha        长度幂律指数 (p(L) ∝ L^{-α})
     * @param kappa        von Mises 浓度 (κ≈0→均匀取向)
     * @param avoidOverlap 是否简单避让已有裂缝重叠
     */
    void generateDFN(int N, const Vector& minPoint, const Vector& maxPoint, double Lmin, double Lmax, double alpha, double kappa, bool avoidOverlap);
    
    //@brief 添加裂缝
    void addFracture(const Vector& start, const Vector& end);  
        
    //@brief 将 globalFFPts 中的每个裂缝–裂缝交点分发至对应两条裂缝的 intersections 中
    void DistributeFracture_FractureIntersectionsToGlobalInersections();  
    
    //@brief 输出所有裂缝和交点信息
    void printFractureInfo() const; 
	
    //@brief 检测裂缝–裂缝交点
    void DetectFracturetoFractureIntersections(); 
	
    //@brief 去重并重新编号裂缝–裂缝交点
    void DeduplicateAndRenumberFractureToFractureIntersections(); 
    
    //@brief 导出裂缝网络信息到文本文件
    void exportToTxt(const string& prefix) const;  
	
    //@brief 判断两个点是否在给定的公差范围内相等
    bool isClose(const Vector& a, const Vector& b, double tol = 1e-6) const; 

private:
    int nextFracID_{ 0 };          ///< 递增的裂缝 ID
    FracElemIndex fracElemIndex_;
    bool fracElemIndexValid_ = false;
};
```

```C++
//FractureNetwork.cpp
#include "FractureNetwork.h"
#include <algorithm>
#include <cmath>
#include <iostream> 
#include <iomanip>  
#include <unordered_map>
#include <tuple>
#include <numeric>      // accumulate
#include <cmath>

// 自定义 PI
static constexpr double PI = 3.14159265358979323846;

///------------DFN生成相关辅助函数-------------///
// uniform [0,1)
static double uniformRand() {
    return double(std::rand()) / double(RAND_MAX);
}

// von Mises (Best–Fisher), mean=0
static double sampleVonMises(double kappa) {
    if (kappa < 1e-6) {
        return uniformRand() * 2.0 * PI;
    }
    double a = 1.0 + std::sqrt(1.0 + 4.0 * kappa * kappa);
    double b = (a - std::sqrt(2.0 * a)) / (2.0 * kappa);
    double r = (1.0 + b * b) / (2.0 * b);
    while (true) {
        double u1 = uniformRand();
        double u2 = uniformRand();
        double z = std::cos(PI * u1);
        double f = (1.0 + r * z) / (r + z);
        double c = kappa * (r - f);
        if (u2 < c * (2.0 - c) || std::log(u2) <= c - 1.0) 
        {
            double u3 = uniformRand();
            double theta = std::acos(f);
            return (u3 > 0.5 ? theta : 2.0 * PI - theta);
        }
    }
}

// 2D segment–segment intersection test
static bool segmentsIntersect(const Vector& a1, const Vector& a2,
    const Vector& b1, const Vector& b2) {
    auto cross = [](double x1, double y1, double x2, double y2) {
        return x1 * y2 - y1 * x2;
        };
    Vector r{ a2.m_x - a1.m_x, a2.m_y - a1.m_y, 0.0 };
    Vector s{ b2.m_x - b1.m_x, b2.m_y - b1.m_y, 0.0 };
    double denom = cross(r.m_x, r.m_y, s.m_x, s.m_y);
    if (std::fabs(denom) < 1e-12) return false;
    Vector d{ b1.m_x - a1.m_x, b1.m_y - a1.m_y, 0.0 };
    double t = cross(d.m_x, d.m_y, s.m_x, s.m_y) / denom;
    double u = cross(d.m_x, d.m_y, r.m_x, r.m_y) / denom;
    return (t >= 0.0 && t <= 1.0 && u >= 0.0 && u <= 1.0);
}

void FractureNetwork::setRandomSeed(unsigned seed)
{
	std::srand(seed);
}
// ----------------------------------------------------------------------------


void FractureNetwork::generateDFN(
    int N,
    const Vector& minPoint,
    const Vector& maxPoint,
    double Lmin,
    double Lmax,
    double alpha,
    double kappa,
    bool avoidOverlap
) {
    // helper: power-law length
    auto sampleLength = [&]() {
        double u = uniformRand();
        double c0 = std::pow(Lmin, 1.0 - alpha);
        double c1 = std::pow(Lmax, 1.0 - alpha);
        return std::pow(c0 + u * (c1 - c0), 1.0 / (1.0 - alpha));
        };

    int created = 0, attempts = 0, maxAttempts = N * 10;
    while (created < N && attempts < maxAttempts) {
        ++attempts;
        // 1) center
        double cx = minPoint.m_x + uniformRand() * (maxPoint.m_x - minPoint.m_x);
        double cy = minPoint.m_y + uniformRand() * (maxPoint.m_y - minPoint.m_y);
        double cz = minPoint.m_z + uniformRand() * (maxPoint.m_z - minPoint.m_z);
        Vector C{ cx,cy,cz };

        // 2) length & orientation
        double L = sampleLength();
        double theta = sampleVonMises(kappa);

        // 3) endpoints
        double dx = 0.5 * L * std::cos(theta),
            dy = 0.5 * L * std::sin(theta);
        Vector s{ C.m_x + dx, C.m_y + dy, C.m_z };
        Vector e{ C.m_x - dx, C.m_y - dy, C.m_z };

        // 4) boundary check
        if (s.m_x<minPoint.m_x || s.m_x>maxPoint.m_x ||
            s.m_y<minPoint.m_y || s.m_y>maxPoint.m_y ||
            e.m_x<minPoint.m_x || e.m_x>maxPoint.m_x ||
            e.m_y<minPoint.m_y || e.m_y>maxPoint.m_y)
            continue;

        // 5) optional overlap avoidance
        if (avoidOverlap) {
            bool bad = false;
            for (auto const& F : fractures) {
                if (!F.intersections.empty()) {
                    Vector a1 = F.intersections.front().point;
                    Vector a2 = F.intersections.back().point;
                    if (segmentsIntersect(s, e, a1, a2)) { bad = true; break; }
                }
            }
            if (bad) continue;
        }

        // 6) finally add
        addFracture(s, e);
        ++created;
    }

    if (created < N) {
        std::cerr << "[Warning] only " << created
            << " of " << N << " fractures.\n";
    }
}

//-------------------------------------------------------------------------------------------------//

//-------------添加一条裂缝--------------//

void FractureNetwork::addFracture(const Vector& s, const Vector& e)
{
    fractures.emplace_back(s, e);           // 1. 先放进容器
    auto& f = fractures.back();             // 2. 取出刚刚插入的那条
    f.id = nextFracID_++;                // 3. 写入唯一 ID
}

/// 检测裂缝之间的交点
void FractureNetwork::DetectFracturetoFractureIntersections()
{
    globalFFPts.clear();
    int nextID = 1;
    for (size_t i = 0; i < fractures.size(); ++i) 
    {
        const auto& Fi = fractures[i];
        Vector p = Fi.start, q = Fi.end;
        double L = (q - p).Mag();
        //cout << "第" << Fi.id << "条裂缝的长度为" << L << endl;
        for (size_t j = i + 1; j < fractures.size(); ++j) 
        {
            const auto& Fj = fractures[j];
            Vector r = Fj.start, s = Fj.end;
            Vector ip;
            if (Fracture::lineSegmentIntersection(p, q, r, s, ip)) 
            {
                //cout << "第" << Fi.id << "条和第" << Fj.id << "条裂缝的交点坐标为（" << ip.m_x << "," << ip.m_y << "," << ip.m_z << "）" << endl;
                // 计算各自的 param
                double ti = L > 1e-12 ? (ip - p).Mag() / L : 0.0;
                double L2 = (s - r).Mag();
                double tj = L2 > 1e-12 ? (ip - r).Mag() / L2 : 0.0;
                globalFFPts.push_back({ nextID++, ip, int(i), int(j), ti, tj });
            }
        }
    }
}

/// 对裂缝与裂缝的交点进行去重并编号
void FractureNetwork::DeduplicateAndRenumberFractureToFractureIntersections()
{
    vector<GlobalFFPoint> uniquePts; //
    int gid = 1;
    for (auto& g : globalFFPts)
    {
        bool found = false;
        for (auto& u : uniquePts)
        {
            if (isClose(g.point, u.point)) { found = true; break; }
        }
        if (!found)
        {
            g.id = gid++;
            uniquePts.push_back(g);
        }
    }
    globalFFPts.swap(uniquePts);
}


void FractureNetwork::DistributeFracture_FractureIntersectionsToGlobalInersections()
{
    constexpr double tol = 1e-8;
    for (auto& g : globalFFPts)
    {
        // —— 裂缝 A —— 
        {
            auto& FA = fractures[g.fracA];
            // 在 FA.intersections 中查找：有没有已有的交点其 param 与 g.paramA 极其接近
            auto it = std::find_if(FA.intersections.begin(), FA.intersections.end(),
                [&](auto& ip) {
                    return std::abs(ip.param - g.paramA) < tol;
                });
            if (it != FA.intersections.end()) {
                // 找到了，就“升级”这条记录，把它标记为裂缝–裂缝交点
                it->isFF = true;
                it->globalFFID = g.id;
                it->origin = IntersectionOrigin::FracFrac;
            }
            else {
                // 没找到，就新 emplace 一个节点
                FA.intersections.emplace_back(
                    -1,                   // id 先用 -1，后面统一重编号
                    g.point,              // 坐标：交点位置
                    -1,                   // edgeID：不是与网格面相交
                    g.paramA,             // param：在裂缝 A 上的位置归一化参数
                    true,                 // isFF：确实是裂缝–裂缝交点
                    g.id,                 // globalFFID：全局交点编号
                    IntersectionOrigin::FracFrac  // origin：来自“裂缝–裂缝”
                );
            }
        }

        // —— 裂缝 B —— 完全同理，只不过用 g.paramB，fractures[g.fracB]
        {
            auto& FB = fractures[g.fracB];
            auto it = std::find_if(FB.intersections.begin(), FB.intersections.end(),
                [&](auto& ip) {
                    return std::abs(ip.param - g.paramB) < tol;
                });
            if (it != FB.intersections.end()) {
                it->isFF = true;
                it->globalFFID = g.id;
                it->origin = IntersectionOrigin::FracFrac;
            }
            else {
                FB.intersections.emplace_back(
                    -1,
                    g.point,
                    -1,
                    g.paramB,
                    true,
                    g.id,
                    IntersectionOrigin::FracFrac
                );
            }
        }
    }
}


/// 判断两个点是否在给定的公差范围内相等
bool FractureNetwork::isClose(const Vector& a, const Vector& b, double tol) const
{
    return (a - b).Mag() < tol;
}

void FractureNetwork::printFractureInfo() const
{
    std::cout << "\n========= Fracture Information =========\n";
    for (size_t fid = 0; fid < fractures.size(); ++fid)
    {
        const auto& F = fractures[fid];
        std::cout << "Fracture #" << fid + 1 << "  ("
            << F.start.m_x << "," << F.start.m_y << ")  →  ("
            << F.end.m_x << "," << F.end.m_y << ")\n";

        std::cout << "  --- Segments ------------------------------------------\n";
        for (const auto& E : F.elements)
        {
            /* ① 取该段的两端交点 */
            const auto& I1 = F.intersections[E.id - 1];
            const auto& I2 = F.intersections[E.id];

            std::cout << "Seg:" << std::setw(2) << E.id
                << "  Cell " << std::setw(2) << E.cellID
                << " | L=" << E.length
                << "  d=" << E.avgDistance << "\n";

            /* ② 打印端点坐标及其在裂缝上的编号 */
            std::cout << "     Pt" << I1.id << " (" << I1.point.m_x << "," << I1.point.m_y << ")"
                << "  →  Pt" << I2.id << " (" << I2.point.m_x << "," << I2.point.m_y << ")\n";

            /* ③ 打印离散系数 */
            std::cout << "     aW=" << E.aW_fr
                << "  aE=" << E.aE_fr
                << "  aP=" << E.aP_fr
                << "  CI—1=" << E.b_fr << "\n";

            std::cout << "     alpha=" << E.geomAlpha << "\n";


            std::cout << "     geomCI=" << E.geomCI
                << "  CI_phys=" << E.b_fr
                << "  alpha_phys=" << E.alpha_fr << "\n";



            /* ④ 若存在 TI，与其它裂缝段的交换信息 */
            if (!E.ffEx.empty())
            {
                std::cout << "     TI exchanges (" << E.ffEx.size() << "):\n";
                for (const auto& ex : E.ffEx)
                {
                    std::cout << "        → Frac "
                        << ex.peerFracID + 1 << "  Seg "
                        << ex.peerSegID + 1 << " : TI=";
                        //<< ex.TI << "\n";
                }
            }
        }
    }

    /* 全局 FF 交点一览 ---------------------------------------------------*/
    std::cout << "\n========= Global Fracture–Fracture Intersections =========\n";
    for (const auto& g : globalFFPts)
    {
        std::cout << "ID " << g.id << "  :  Frac "
            << g.fracA + 1 << "  &  " << g.fracB + 1
            << "   (" << g.point.m_x << "," << g.point.m_y << ")\n";
    }
}

void FractureNetwork::exportToTxt(const std::string& prefix) const
{
    /*================ 1. 裂缝段端点文件  ================*/
    std::ofstream fsSeg(prefix + "_fractureSegments.txt");
    fsSeg << "fid segid  x1  y1  x2  y2  mx  my  cellID\n";

    for (size_t fid = 0; fid < fractures.size(); ++fid)
    {
        const auto& F = fractures[fid];

        for (const auto& elem : F.elements)
        {
            /* 找到该段在 intersections 中的两端点：
               subdivide() 保证 elem.id == its position starting at 1 */
            const auto& I = F.intersections;
            const Vector& p1 = I[elem.id - 1].point;
            const Vector& p2 = I[elem.id].point;

            Vector mid = 0.5 * (p1 + p2);

            fsSeg << fid + 1 << " "
                << elem.id << " "
                << p1.m_x << " " << p1.m_y << " "
                << p2.m_x << " " << p2.m_y << " "
                << mid.m_x << " " << mid.m_y << " "
                << elem.cellID << "\n";
        }
    }
    fsSeg.close();

    /*================ 2. 裂缝-裂缝交点坐标  ================*/
    std::ofstream fsFF(prefix + "_ffPoints.txt");
    fsFF << "id  x  y  fracA  segA  fracB  segB\n";

    /* 为避免星形交点重复，两点容差以内只写一次。
       这里直接用 globalFFPts 的 id，若同一点有多对 fracA/fracB，
       会生成多条记录，但坐标相同；可由绘图脚本自动合并显示。   */

    for (const auto& g : globalFFPts)
    {
        fsFF << g.id << " "
            << g.point.m_x << " " << g.point.m_y << " "
            << g.fracA + 1 << " "
            << fractures[g.fracA].locateSegment(g.paramA) + 1 << " "
            << g.fracB + 1 << " "
            << fractures[g.fracB].locateSegment(g.paramB) + 1 << "\n";
    }
    fsFF.close();

    /*================ 3. 可选：TI 系数  ===================*/
    std::ofstream fsTI(prefix + "_ffTI.csv");
    fsTI << "fracA,segA,fracB,segB,TIw,TIg\n";
    for (size_t fid = 0; fid < fractures.size(); ++fid) {
        const auto& F = fractures[fid];
        for (size_t sid = 0; sid < F.elements.size(); ++sid) {
            const auto& elem = F.elements[sid];
            for (const auto& ex : elem.ffEx) {
                // 只写一次（避免重复）：
                if (fid < (size_t)ex.peerFracID || (fid == (size_t)ex.peerFracID && sid < (size_t)ex.peerSegID)) {
                    fsTI << (fid + 1) << "," << (sid + 1) << ","
                        << (ex.peerFracID + 1) << "," << (ex.peerSegID + 1) << ","
                        << ex.TIw << "," << ex.TIg << "\n";
                }
            }
        }
    }
    fsTI.close();
}
```

```C++
//FracIndex.h
#pragma once
#include <vector>
#include <cstddef>


class FractureNetwork;

struct FracElemIndex {
    std::vector<std::size_t> offset;  // size = fractures.size() + 1
    std::size_t total = 0;
};


FracElemIndex buildFracElemIndex(const FractureNetwork& frNet);
```

```C++
//FracIndex.cpp
#include "FracIndex.h"
#include "FractureNetwork.h" 
#include <cstddef>

FracElemIndex buildFracElemIndex(const FractureNetwork& frNet)
{
    FracElemIndex idx;
    idx.offset.resize(frNet.fractures.size() + 1, 0);
    std::size_t acc = 0;
    for (std::size_t f = 0; f < frNet.fractures.size(); ++f) {
        idx.offset[f] = acc;
        acc += frNet.fractures[f].elements.size();
    }
    idx.offset.back() = acc;
    idx.total = acc;
    return idx;
}
```

```c++
//Fracture.h
#pragma once
#include <vector>
#include <algorithm>
#include <cmath>
#include "UserDefineVarType.h"  // 定义 Vector 类型（即 Variable3D<double>）
#include "Cell.h"
#include "Face.h"
#include "Node.h"
#include "Mesh.h"
#include "FractureSolidProperties.h"

/// 交点来源类型进行枚举
enum class IntersectionOrigin 
{
    FracFrac,       // 裂缝–裂缝交点
    FracFace,       // 裂缝–网格面交点
    FracStart,      // 裂缝起点
    FracEnd         // 裂缝终点
};
enum class DistanceMetric 
{
	CellCenter, // 使用单元中心点距离
	NodeAverage, // 使用单元节点平均位置距离
	AreaWeight,   // 使用面积加权的“数值积分” <d> = sum(d_j * ΔS_j) / S
    CrossAwareGauss 
};
struct FractureIntersectionPointByMatrixMesh  //// 用于描述裂缝与基岩网格面交点的结构体
{
	int id; // 交点编号
	Vector point; // 交点坐标
	int edgeID; // 与之相交的边（Face）的编号；若无则为 -1
	double param; // 裂缝起点到交点在裂缝线段上的归一化参数（0～1）
    bool    isFF;         // <<< 是否是裂缝–裂缝交点
    int     globalFFID;   // <<< 全局 FF 交点的 ID（face 交点填 0）
    IntersectionOrigin origin;   ///交点的“来源”
    
    FractureIntersectionPointByMatrixMesh(int _id,
        const Vector& _pt,
        int _edgeID,
        double _param,
        bool _isFF = false,
        int  _globalID = 0,
        IntersectionOrigin _orig = IntersectionOrigin::FracFace)
        : id(_id)
        , point(_pt)
        , edgeID(_edgeID)
        , param(_param)
        , isFF(_isFF)
        , globalFFID(_globalID)
        , origin(_orig)
    {
	} //有参构造函数
};
struct FractureElement  ///// 描述裂缝单元（裂缝段）的结构体
{
    
	// ————— 编号信息 —————  （在哪里）
    int id;                  ///< 裂缝单元序号
    int cellID;              ///< 裂缝单元所在基岩网格单元编号
    // —————— 几何信息 —————— （有多大）
	double aperture = 1.0;         ///< 裂缝单元开度 w
    double length = 0.0;           ///< 裂缝单元长度 L
    double avgDistance =0.0;      ///< 平均距离 d
    double geomCI = 0.0;   ///< 纯几何耦合系数  CI_geom = (L·w) / d
    double geomAlpha = 0.0;   ///< 纯几何 α_geom = 2·w / L  可以进一步修正
    //——————裂缝段类型———————
    FractureElementType type = FractureElementType::Conductive;
	///< 裂缝段类型（阻塞/导流）

    // —————— 物性耦合 & 离散系数 —————— （储存离散系数）
    double alpha_fr = 0.0;   ///< TI 计算用 α_phys = 2·w·k / (μ·L)
    double k_eff = 0.0;   ///< 并联系统有效渗透率
    double aW_fr = 0.0;   ///< 左邻接段导流系数
    double aE_fr = 0.0;   ///< 右邻接段导流系数
    double b_fr = 0.0;   ///< 裂缝–基岩源项系数 CI_phys = θ·A / d
    double aP_fr = 0.0;   ///< 本段总离散系数 aW+aE+b
    // —————— 归一化参数区间 ——————
    double param0 = 0.0;   ///< 本段起始归一化位置
    double param1 = 0.0;   ///< 本段终止归一化位置
    // —— 裂缝–裂缝 TI 交换信息 ——
    struct FFF_Exchange
    {
		int peerFracID{ -1 }; // 对端裂缝编号
		int peerSegID{ -1 };  // 对端裂缝段编号
        int peerGlobalSeg{ -1 };   // 对端全局段索引（便于快速定位）
		int atGlobalFF{ -1 };	  // 所在全局 FF 交点编号
        double TIw{ 0.0 };         // 水相交汇导纳（Star–Delta 后的“边”）
        double TIg{ 0.0 };         // 气相交汇导纳
    };
    vector<FFF_Exchange> ffEx;

    bool isFFatStart = false, isFFatEnd = false;
    int  gIDstart = 0, gIDend = 0;

    FractureElement(int id_, int cellID_, double len = 0.0, double avgDist = 0.0)
        : id(id_)
        , cellID(cellID_)
        , length(len)
        , avgDistance(avgDist)
    {
        // 其余成员已经在声明处给出默认值
    }
};
class Fracture  
{
public:
	
    /*=====构造函数=====*/
    Fracture(const Vector& s, const Vector& e);
	/*===裂缝编号===*/ 
	int id  ; // 裂缝编号     
    /*===裂缝起点终点信息===*/
    Vector start; // 裂缝起点坐标
	Vector end;   // 裂缝终点坐标
	/*===存储裂缝交点及裂缝段信息===*/
	vector<FractureIntersectionPointByMatrixMesh> intersections; 
	vector<FractureElement> elements;		  
    //构建每条裂缝的AABB
	AABB fractureBox; // 裂缝的包围盒（用于碰撞检测等）
    int candidateFaceCount_ = 0; // 可选加 mutable
	// 计算裂缝与网格面交点
    void DetectFracturetoMeshFaceIntersections(const Mesh& mesh, const std::vector<Cell>& meshCells, const std::unordered_map<int, Node>& meshNodes, bool useAABBFilter);
    void computeAABB();
	// 排序交点并重新编号
    void sortAndRenumberIntersections();
    //裂缝段划分
    void subdivide(const vector<Cell>& meshCells, const unordered_map<int, Node>& meshNodes, DistanceMetric metric);
/// -/*=== 计算几何耦合系数 geomCI 和 geomAlpha======*/
    void computeGeometryCouplingCoefficientgeomCIandgeomAlpha();     
    /*==裂缝段离散====*/
    /*== 给定 param，定位它属于哪一段====*/
    int locateSegment(double param) const;

    static bool lineSegmentIntersection(const Vector& p, const Vector& q, const Vector& r, const Vector& s, Vector& ip);
 private:
    
    double computeSegmentLength(const Vector& a, const Vector& b);
    Vector computeMidpoint(const Vector& a, const Vector& b);
    int findContainingCell(const Vector& point, const std::vector<Cell>& cells, const std::unordered_map<int, Node>& nodes);
    static double computeAverageDistanceFromNodes(const Cell& cell, const std::unordered_map<int, Node>& meshNodes, const Vector& segStart, const Vector& segEnd);
    static double computeDistanceFromCenter(const Cell& cell, const Vector& segStart, const Vector& segEnd);
    static double computeAreaWeightedDistance(const Cell& cell, const std::unordered_map<int, Node>& meshNodes, const Vector& segStart, const Vector& segEnd);
    static double computeCrossAwareAverageDistance(const Cell& cell, const std::unordered_map<int, Node>& meshNodes, const Vector& segStart, const Vector& segEnd);
};
```

```C++
// Fracture.cpp
#include "Fracture.h"
#include <algorithm>
#include <cmath>
#include <iostream>
#include "Mesh.h"
#include <unordered_map>
#include <numeric>
#include "FractureGeometryUtils.h"


Fracture::Fracture(const Vector& s, const Vector& e)  
   : start(s), end(e), id(0)  
{  

}

double Fracture::computeCrossAwareAverageDistance(
    const Cell& cell,
    const std::unordered_map<int, Node>& meshNodes,
    const Vector& segStart, const Vector& segEnd)
{
    // 取单元多边形
    std::vector<Vector> poly; poly.reserve(cell.CellNodeIDs.size());
    for (int nid : cell.CellNodeIDs) poly.push_back(meshNodes.at(nid).coord);
    if (poly.size() < 3) {
        // 退化：回退到中心点距离
        return FractureGeom::pointToSegmentDistance(cell.center, segStart, segEnd);
    }

    // 判断是否“穿越”
    std::vector<Vector> hits;
    int nHit = FractureGeom::countIntersectionsWithPolygon(poly, segStart, segEnd, hits);
    if (nHit >= 2) {
        // 按直线把多边形一分为二，两个子多边形分别 fan + Gauss，再面积加权
        std::vector<Vector> Ppos, Pneg;
        FractureGeom::splitPolygonByLine(poly, segStart, segEnd, Ppos, Pneg);

        double areaPos = 0.0, areaNeg = 0.0;
        if (Ppos.size() >= 3) { Vector c = FractureGeom::polygonCentroid(Ppos, areaPos); (void)c; }
        if (Pneg.size() >= 3) { Vector c = FractureGeom::polygonCentroid(Pneg, areaNeg); (void)c; }
        double A = areaPos + areaNeg;
        if (A <= 0) {
            // 极端退化：回退到原扇形 + 高斯
            return FractureGeom::fanGaussAverage(poly, segStart, segEnd);
        }

        double favPos = (areaPos > 0 && Ppos.size() >= 3) ? FractureGeom::fanGaussAverage(Ppos, segStart, segEnd) : 0.0;
        double favNeg = (areaNeg > 0 && Pneg.size() >= 3) ? FractureGeom::fanGaussAverage(Pneg, segStart, segEnd) : 0.0;

        return (favPos * areaPos + favNeg * areaNeg) / A;
    }
    else {
        // 不穿越：直接对原多边形做扇形 + 三点高斯
        return FractureGeom::fanGaussAverage(poly, segStart, segEnd);
    }
}


double Fracture::computeAreaWeightedDistance(const Cell& cell,
    const std::unordered_map<int, Node>& meshNodes,
    const Vector& segStart, const Vector& segEnd)
{
    // 取多边形顶点（按 cell 拓扑顺序）
    std::vector<Vector> poly;
    poly.reserve(cell.CellNodeIDs.size());
    for (int nid : cell.CellNodeIDs) poly.push_back(meshNodes.at(nid).coord);

    if (poly.size() < 3) {
        // 极端/退化：回退到中心距离
        return FractureGeom::pointToSegmentDistance(cell.center, segStart, segEnd);
    }

    double polyArea = 0.0;
	Vector C = FractureGeom::polygonCentroid(poly, polyArea); // 多边形重心

    double sum = 0.0, sumA = 0.0;
    const size_t n = poly.size();
    for (size_t i = 0; i < n; ++i) {
        const Vector& A = poly[i];
        const Vector& B = poly[(i + 1) % n];
        double Ai = FractureGeom::triArea(C, A, B);
        if (Ai <= 0) continue;
        Vector Gi = FractureGeom::triCentroid(C, A, B);
        double di = FractureGeom::pointToSegmentDistance(Gi, segStart, segEnd);
        sum += di * Ai;
        sumA += Ai;
    }

    if (sumA <= 0) {
        // 再次回退
        return FractureGeom::pointToSegmentDistance(cell.center, segStart, segEnd);
    }
    return sum / sumA;
}

void Fracture::computeAABB()
{
    Vector minCoord, maxCoord;
	minCoord.m_x = std::min(start.m_x, end.m_x);
	minCoord.m_y = std::min(start.m_y, end.m_y);
	minCoord.m_z = std::min(start.m_z, end.m_z);

	maxCoord.m_x = std::max(start.m_x, end.m_x);
	maxCoord.m_y = std::max(start.m_y, end.m_y);
	maxCoord.m_z = std::max(start.m_z, end.m_z);
	fractureBox = AABB(minCoord, maxCoord); // 计算包围盒
}


/*====利用基岩网格边界对裂缝进行网格划分并排序---基于lineSegmentIntersection子函数 *注：对于非结构化网格需要进行排序===*/
void Fracture::DetectFracturetoMeshFaceIntersections(const Mesh& mesh,const vector<Cell>& meshCells,const unordered_map<int, Node>& meshNodes,bool useAABBFilter)
{
    /* =========================================================
   0. 基本准备：裂缝自身 AABB 以及要遍历的面列表
   =========================================================*/

	AABB fractureBox(start, end); // 计算裂缝的包围盒
	vector<int> faceIDList; // 用于存储需要遍历的面 ID

    if (useAABBFilter)
    {
		faceIDList = mesh.getCandidateFacesFromBins(fractureBox); // 获取与裂缝包围盒相交的面 ID 列表
        candidateFaceCount_ = static_cast<int>(faceIDList.size());
    }
    else
    {
        const auto& faces = mesh.getFaces();
		faceIDList.resize(faces.size());
		iota(faceIDList.begin(), faceIDList.end(), 1); // 如果不使用 AABB 过滤，则遍历所有面
    }

    /* =========================================================
       1. 精确检测：裂缝-面交点 & 去重
       =========================================================*/
    intersections.clear();
	const auto&  faces= mesh.getFaces(); // 获取网格面的引用

    for (int fid : faceIDList)
    {

		const Face& face = faces[fid - 1]; // 获取面对象（ID 从 1 开始）
		if (face.FaceNodeCoords.size() < 2) continue; // 跳过无效面
        
        /* —— 二次快速剔除：裂缝盒 vs. 面盒 —— */

		if (useAABBFilter && !fractureBox.overlaps(face.boundingBox)) continue; // 如果裂缝包围盒与面包围盒不相交则跳过

		const Vector& A = face.FaceNodeCoords[0]; // 网格面的两个节点坐标
		const Vector& B = face.FaceNodeCoords[1]; // 网格面的两个节点坐标

		Vector ip; // 存储交点坐标

		if (!lineSegmentIntersection(start, end, A, B, ip)) continue; // 判断裂缝(start→end) 与 面(A→B) 的线段是否相交,并输出交点坐标到 ip

        //在裂缝上的归一化位置 param ∈ [0,1]
		double segLen = (end - start).Mag(); // 计算裂缝总长度用于计算归一化参数
		double t = (segLen > 1e-8 ? (ip - start).Mag() / segLen : 0.0); // 计算归一化参数，用于后面排序
		// 如果本 face 上已有一个非常接近的点，就跳过
		bool dup = false;
		for (const auto& e : intersections)
			if (e.edgeID == face.id && (e.point - ip).Mag() < 1e-8)
			{
				dup = true;
				break;
			}
		if (dup) continue; // 如果是重复点则跳过
		// 添加新的交点
		intersections.emplace_back(-1, ip, face.id, t, false, 0, IntersectionOrigin::FracFace); 
    }

    /* =========================================================
       2. 起点 / 终点 也要算交点（若尚未包含）
       =========================================================*/
    bool startIncluded = false, endIncluded = false;
    for (auto& e : intersections)
    {
        if ((e.point - start).Mag() < 1e-6) startIncluded = true;  //如果其中有一个交点与起点重合那么起点就是交点
        if ((e.point - end).Mag() < 1e-6) endIncluded = true;      //如果其中有一个交点与终点重合那么终点就是交点
    }
    if (!startIncluded)
        intersections.emplace_back
        (
			-1,                     //id(稍后再排)
			start,                  //起点坐标
			-1,                     //关联的 faceID
			0.0,                    // param    
            false,                  // isFF（不是裂缝–裂缝交点）
            0,                      // globalFFID
            IntersectionOrigin::FracStart  // 来源：裂缝起点
        );// 起点
    if (!endIncluded)
        intersections.emplace_back
        (
            -1,
            end,
            -1,
            1.0,
            false,
            0,
            IntersectionOrigin::FracEnd    // 【新增】来源：裂缝终点
        );   // 终点

    /* =========================================================
      3. 排序（按 param）并暂编号
      =========================================================*/
    std::sort(intersections.begin(), intersections.end(),
        [](const FractureIntersectionPointByMatrixMesh& a, const FractureIntersectionPointByMatrixMesh& b)
        {
            return a.param < b.param;
        });
    for (int i = 0; i < intersections.size(); ++i)
        intersections[i].id = i + 1;
    /* =========================================================
   4. 建立 “Cell → 交点” 映射，只保留每个 Cell 最靠前的两个点
   =========================================================*/
    std::unordered_map<int, std::vector<FractureIntersectionPointByMatrixMesh>> perCell;

    for (auto& ip : intersections) {
        int cid = -1;

        if (ip.edgeID >= 1 && ip.edgeID <= (int)faces.size()) {
            // 通过边直接找到宿主 Cell
            const Face& f = faces[ip.edgeID - 1];
            cid = (f.ownerCell >= 0 ? f.ownerCell : f.neighborCell);
        }
        else {
            // 起点/终点：靠几何定位
            cid = findContainingCell(ip.point, meshCells, meshNodes);
        }

        if (cid >= 0)  perCell[cid].push_back(ip);
        else {
            std::cerr << "[Warn] 交点无法匹配 Cell (faceID="
                << ip.edgeID << ")\n";
        }
    }
    std::vector<FractureIntersectionPointByMatrixMesh> filtered;
    for (auto& kv : perCell) {
        auto& v = kv.second;
        if (v.empty()) continue;
        std::sort(v.begin(), v.end(),
            [](auto& a, auto& b) { return a.param < b.param; });
        int take = std::min(2, (int)v.size());
        filtered.insert(filtered.end(), v.begin(), v.begin() + take);
    }

    /* =========================================================
       5. 距离过近(<1e-8) 的点再剔除，最终重编号
       =========================================================*/
    std::sort(filtered.begin(), filtered.end(),
        [](auto& a, auto& b) { return a.param < b.param; });

    std::vector<FractureIntersectionPointByMatrixMesh> cleaned;
    for (const auto& ip : filtered) {
        if (!cleaned.empty() && (ip.point - cleaned.back().point).Mag() < 1e-8)
            continue;
        cleaned.push_back(ip);
    }

    for (int i = 0; i < (int)cleaned.size(); ++i)
        cleaned[i].id = i + 1;

    intersections.swap(cleaned);
}

// ====== 根据裂缝交点对裂缝进行划分 ======
void Fracture::subdivide(const std::vector<Cell>& meshCells,
    const std::unordered_map<int, Node>& meshNodes,
    DistanceMetric metric)
{
    elements.clear();
    constexpr double tolLen = 1e-10;
    constexpr double tolPoint = 1e-8;

    for (int i = 0; i + 1 < (int)intersections.size(); ++i)
    {
        const auto& I0 = intersections[i];
        const auto& I1 = intersections[i + 1];

        Vector P0 = I0.point, P1 = I1.point;
        double segLen = computeSegmentLength(P0, P1);
        if (segLen < tolLen) {
            std::cerr << "Warning: Zero-length fracture segment @("
                << P0.m_x << "," << P0.m_y << ")\n";
            continue;
        }

        Vector mid = computeMidpoint(P0, P1);
        int associatedCellID = findContainingCell(mid, meshCells, meshNodes);
        if (associatedCellID < 0) {
            std::cerr << "[提示] 裂缝段 param=[" << I0.param << "," << I1.param
                << "] 未匹配到单元，已跳过\n";
            continue;
        }

        double avgDist = -1.0;
        // 找到 cell 对象
        const Cell* host = nullptr;
        for (const auto& c : meshCells) if (c.id == associatedCellID) { host = &c; break; }
        if (!host) {
            std::cerr << "[警告] 找不到 id=" << associatedCellID << " 的单元\n";
            continue;
        }

        // ——— 这里切换三种算法 ———
        switch (metric) {
        case DistanceMetric::CellCenter:
            avgDist = computeDistanceFromCenter(*host, P0, P1);
            break;
        case DistanceMetric::NodeAverage:
            avgDist = computeAverageDistanceFromNodes(*host, meshNodes, P0, P1);
            break;
        case DistanceMetric::AreaWeight:
            avgDist = computeAreaWeightedDistance(*host, meshNodes, P0, P1);
            break;
        case DistanceMetric::CrossAwareGauss:  
            avgDist = computeCrossAwareAverageDistance(*host, meshNodes, P0, P1);
            break;
        default:
            avgDist = computeAreaWeightedDistance(*host, meshNodes, P0, P1);
            break;
        }

        int newElemId = static_cast<int>(elements.size()) + 1;
        FractureElement elem(newElemId, associatedCellID, segLen, avgDist);
        elem.param0 = I0.param; elem.param1 = I1.param;
        elem.isFFatStart = I0.isFF; elem.isFFatEnd = I1.isFF;
        elem.gIDstart = I0.globalFFID; elem.gIDend = I1.globalFFID;
        elements.push_back(elem);
    }
}

int Fracture::locateSegment(double param) const
{
    for (int i = 0; i < (int)elements.size(); ++i) {
        if (param >= elements[i].param0 && param <= elements[i].param1)
            return i;
    }
    return -1;  // 找不到就返回 -1
}

void Fracture::computeGeometryCouplingCoefficientgeomCIandgeomAlpha()
{
    constexpr double eps_d = 1e-12;
    // 逐段填充纯几何耦合系数
    for (auto& elem : elements)
    {
        //基岩网格各端点到裂缝段的平均距离d 
        double d = max(elem.avgDistance, eps_d);
        // 横截面积 = 段长 * 裂缝厚度（2D 为1）
        double A_fr = elem.length * 1;  //Note: 2D中 此时为1m 
        // geomCI: 纯几何耦合  CI = Af/d  ref:Modeling study of the thermal-hydraulic-mechanical coupling process for EGS based on the framework of EDFM and XFEM
        elem.geomCI = A_fr / d;
		// geomAlpha: 纯几何 α  alpha= 2/ L ref:Modeling study of the thermal-hydraulic-mechanical coupling process for EGS based on the framework of EDFM and XFEM
        elem.geomAlpha = 2.0 / elem.length;
    }
}

// -----------------------------------------------------------------------------
/*====判断两线段是否有交点且在两线段内 （lineSegmentIntersection）====*/
bool Fracture::lineSegmentIntersection(const Vector& p, const Vector& q, const Vector& r, const Vector& s, Vector& ip) 
{
    if (std::max(p.m_x, q.m_x) < std::min(r.m_x, s.m_x) ||
        std::min(p.m_x, q.m_x) > std::max(r.m_x, s.m_x) ||
        std::max(p.m_y, q.m_y) < std::min(r.m_y, s.m_y) ||
        std::min(p.m_y, q.m_y) > std::max(r.m_y, s.m_y)) {
        return false; // bounding box 不相交
    }
    const double tol = 1e-10;
    // 精确几何检测阶段--向量叉积法
    Vector pq = q - p;
    Vector rs = s - r;

    double denom = pq.m_x * rs.m_y - pq.m_y * rs.m_x;

    // 1) 判断是否平行（或共线）
    if (fabs(denom) < tol) 
    {
        return false;  // 平行或共线，不考虑重合情况
    }

    Vector pr = r - p;

    double t = (pr.m_x * rs.m_y - pr.m_y * rs.m_x) / denom;
    double u = (pr.m_x * pq.m_y - pr.m_y * pq.m_x) / denom;

    // 2) 判断 t、u 是否都在 [0,1] 内（带容差）
    if (t < -tol || t > 1.0 + tol || u < -tol || u > 1.0 + tol) 
    {
        return false;  // 交点不在线段范围内
    }

    // 3) 计算交点
    ip = p + pq * t;
    
    return true;
}

/*====计算裂缝段长度（computeSegmentLength）====*/
double Fracture::computeSegmentLength(const Vector& a, const Vector& b) {
    return (b - a).Mag();
}

/*====计算裂缝段中点坐标（computeMidpoint）====*/
Vector Fracture::computeMidpoint(const Vector& a, const Vector& b) 
{
    return (a + b) / 2.0;
}
// —— 替换你的函数：支持三角/四边形/任意 2D 多边形 ——
// 约定：工作在 XY 平面（你的裂缝/基岩2D情形正是如此）
int Fracture::findContainingCell(const Vector& point,
    const std::vector<Cell>& cells,
    const std::unordered_map<int, Node>& nodes)
{
    int bestCid = -1;
    double bestD2 = 1e300;

    for (const auto& cell : cells) {
        const auto& ids = cell.CellNodeIDs;
        if ((int)ids.size() < 3) continue; // 至少三点

        // 快速 AABB 剪枝（提速）
        double xmin = 1e300, xmax = -1e300, ymin = 1e300, ymax = -1e300;
        for (int nid : ids) {
            const Vector& v = nodes.at(nid).coord;
            xmin = std::min(xmin, v.m_x); xmax = std::max(xmax, v.m_x);
            ymin = std::min(ymin, v.m_y); ymax = std::max(ymax, v.m_y);
        }
        if (point.m_x < xmin - 1e-12 || point.m_x > xmax + 1e-12 ||
            point.m_y < ymin - 1e-12 || point.m_y > ymax + 1e-12) continue;

        // 真正点内测：任意多边形（含三角/四边形）
        if (FractureGeom::pointInPolygon2D(point, ids, nodes))
        {
            // 多个候选时，选重心更近者（更稳）

            double d2 = (point - cell.center).Mag2();
            if (d2 < bestD2) { bestD2 = d2; bestCid = cell.id; }
        }
    }
    return bestCid; // -1 表示未找到
}

/*====计算裂缝段到基岩网格单元的平均距离--方法1利用 Cell 中的各节点计算====*/
double Fracture::computeAverageDistanceFromNodes(const Cell& cell, const std::unordered_map<int, Node>& meshNodes, const Vector& segStart, const Vector& segEnd)
{
    double sumDist = 0.0;
    for (int nid : cell.CellNodeIDs) {
        Vector nodeCoord = meshNodes.at(nid).coord;
        sumDist += FractureGeom::pointToSegmentDistance(nodeCoord, segStart, segEnd);
    }
    return sumDist / cell.CellNodeIDs.size();
}

/*====计算裂缝段到基岩网格单元的平均距离--方法2利用 Cell 中点计算====*/
double Fracture::computeDistanceFromCenter(const Cell& cell, const Vector& segStart, const Vector& segEnd) {
    return FractureGeom::pointToSegmentDistance(cell.center, segStart, segEnd);
}


void Fracture::sortAndRenumberIntersections()
{
    sort(intersections.begin(), intersections.end(),
        [](const FractureIntersectionPointByMatrixMesh& a,
            const FractureIntersectionPointByMatrixMesh& b)
        { return a.param < b.param; });

    int nid = 1;
    for (auto& I : intersections) I.id = nid++;
}
```

```C++
//FractureGeometryUtils.h
#pragma once
#include <algorithm>
#include <cmath>
#include <unordered_map>
#include <vector>
#include "Node.h"
#include "UserDefineVarType.h"

// Internal helper functions for fracture geometry operations.
// Kept header-only to avoid changing build configuration.
namespace FractureGeom
{
    // ===== 2D helpers =====
    // ==================== 2D基础几何函数 ====================

    // 功能：计算2D向量的叉积 (仅考虑x,y分量)
    // 参数：a,b - 输入向量
    // 返回：标量叉积值 (a.x*b.y - a.y*b.x)
    inline double cross2D(const Vector& a, const Vector& b)
    {
        return a.m_x * b.m_y - a.m_y * b.m_x;
    }

    // 功能：计算三角形面积
    // 参数：A,B,C - 三角形三个顶点
    // 返回：三角形面积 (取绝对值)
    inline double triArea(const Vector& A, const Vector& B, const Vector& C)
    {
        return 0.5 * std::abs(cross2D(B - A, C - A));
    }

    // 功能：计算三角形质心
    // 参数：A,B,C - 三角形三个顶点
    // 返回：质心坐标 (三个顶点的平均值)
    inline Vector triCentroid(const Vector& A, const Vector& B, const Vector& C)
    {
        return (A + B + C) / 3.0;
    }

    inline double pointToSegmentDistance_local(
        const Vector& p,
        const Vector& a,
        const Vector& b)
    {
        Vector ab = b - a;
        double L2 = ab.m_x * ab.m_x + ab.m_y * ab.m_y + ab.m_z * ab.m_z;
        if (L2 <= 1e-30) {
            double dx = p.m_x - a.m_x, dy = p.m_y - a.m_y, dz = p.m_z - a.m_z;
            return std::sqrt(dx * dx + dy * dy + dz * dz);
        }
        double t = ((p - a) * ab) / L2;
        if (t < 0.0) t = 0.0; else if (t > 1.0) t = 1.0;
        Vector proj = a + ab * t;
        double dx = p.m_x - proj.m_x, dy = p.m_y - proj.m_y, dz = p.m_z - proj.m_z;
        return std::sqrt(dx * dx + dy * dy + dz * dz);
    }

    // 2D segment–segment intersection test with tolerance.
    inline bool segSegIntersect2D(
        const Vector& p,
        const Vector& p2,
        const Vector& q,
        const Vector& q2,
        Vector& out,
        double eps = 1e-12)
    {
        Vector r = p2 - p;
        Vector s = q2 - q;
        double denom = cross2D(r, s);
        if (std::fabs(denom) < eps) return false; // parallel or nearly parallel

        Vector qp = q - p;
        double t = cross2D(qp, s) / denom;
        double u = cross2D(qp, r) / denom;
        if (t < -eps || t > 1.0 + eps || u < -eps || u > 1.0 + eps) return false;

        t = std::min(1.0, std::max(0.0, t));
        out = p + r * t;
        return true;
    }

    // Count intersections between a segment and polygon edges (deduplicated).
    inline int countIntersectionsWithPolygon(
        const std::vector<Vector>& poly,
        const Vector& s0,
        const Vector& s1,
        std::vector<Vector>& hits,
        double eps = 1e-12)
    {
        hits.clear();
        if (poly.size() < 3) return 0;
        const size_t n = poly.size();
        for (size_t i = 0; i < n; ++i) {
            const Vector& a = poly[i];
            const Vector& b = poly[(i + 1) % n];
            Vector x{};
            if (segSegIntersect2D(s0, s1, a, b, x, eps)) {
                bool dup = false;
                for (const auto& h : hits) {
                    double dx = h.m_x - x.m_x, dy = h.m_y - x.m_y;
                    if (dx * dx + dy * dy < 1e-20) { dup = true; break; }
                }
                if (!dup) hits.push_back(x);
            }
        }
        return (int)hits.size();
    }

    // Split polygon by line s0->s1 (Sutherland–Hodgman style), producing two polygons.
    inline void splitPolygonByLine(
        const std::vector<Vector>& poly,
        const Vector& s0,
        const Vector& s1,
        std::vector<Vector>& pos, // cross>=0 side
        std::vector<Vector>& neg, // cross<=0 side
        double eps = 1e-12)
    {
        pos.clear(); neg.clear();
        const size_t n = poly.size();
        if (n < 3) return;

        Vector nvec = s1 - s0;
        auto sideVal = [&](const Vector& p)->double { return cross2D(nvec, p - s0); };

        for (size_t i = 0; i < n; ++i) {
            const Vector& A = poly[i];
            const Vector& B = poly[(i + 1) % n];
            double sa = sideVal(A);
            double sb = sideVal(B);

            bool AinPos = (sa > eps);
            bool AinNeg = (sa < -eps);
            bool Aon = (!AinPos && !AinNeg);

            bool BinPos = (sb > eps);
            bool BinNeg = (sb < -eps);

            if (AinPos || Aon) pos.push_back(A);
            if (AinNeg || Aon) neg.push_back(A);

            if ((AinPos && BinNeg) || (AinNeg && BinPos)) {
                Vector X{};
                segSegIntersect2D(A, B, s0, s1, X, eps);
                pos.push_back(X);
                neg.push_back(X);
            }
        }

        auto dedup = [](std::vector<Vector>& P) {
            if (P.size() < 3) return;
            std::vector<Vector> out; out.reserve(P.size());
            for (size_t i = 0; i < P.size(); ++i) {
                const auto& cur = P[i];
                const auto& prv = P[(i + P.size() - 1) % P.size()];
                double dx = cur.m_x - prv.m_x, dy = cur.m_y - prv.m_y;
                if (dx * dx + dy * dy > 1e-24) out.push_back(cur);
            }
            P.swap(out);
            };
        dedup(pos);
        dedup(neg);
    }

    // Triangle 3-point Gauss integral for ∫_△ d(x) dS (returns integral, not mean).
    inline double triGauss3Integral(
        const Vector& V1,
        const Vector& V2,
        const Vector& V3,
        const Vector& segStart,
        const Vector& segEnd)
    {
        double area = triArea(V1, V2, V3);
        if (area <= 0.0) return 0.0;

        Vector P1 = V1 * (1.0 / 6.0) + V2 * (1.0 / 6.0) + V3 * (2.0 / 3.0);
        Vector P2 = V1 * (1.0 / 6.0) + V2 * (2.0 / 3.0) + V3 * (1.0 / 6.0);
        Vector P3 = V1 * (2.0 / 3.0) + V2 * (1.0 / 6.0) + V3 * (1.0 / 6.0);

        double d1 = pointToSegmentDistance_local(P1, segStart, segEnd);
        double d2 = pointToSegmentDistance_local(P2, segStart, segEnd);
        double d3 = pointToSegmentDistance_local(P3, segStart, segEnd);

        return (area / 3.0) * (d1 + d2 + d3);
    }

    inline Vector polygonCentroid(const std::vector<Vector>& P, double& areaAbs)
    {
        const size_t n = P.size();
        double A2 = 0.0, Cx = 0.0, Cy = 0.0;
        for (size_t i = 0; i < n; ++i) {
            const auto& p = P[i];
            const auto& q = P[(i + 1) % n];
            double cr = p.m_x * q.m_y - q.m_x * p.m_y;
            A2 += cr;
            Cx += (p.m_x + q.m_x) * cr;
            Cy += (p.m_y + q.m_y) * cr;
        }
        double A = 0.5 * A2;
        areaAbs = std::abs(A);
        if (std::abs(A) < 1e-16) {
            double mx = 0.0, my = 0.0;
            for (auto& p : P) { mx += p.m_x; my += p.m_y; }
            return Vector{ mx / n, my / n, 0.0 };
        }
        return Vector{ Cx / (3.0 * A2), Cy / (3.0 * A2), 0.0 };
    }

    inline double fanGaussAverage(
        const std::vector<Vector>& poly,
        const Vector& segStart,
        const Vector& segEnd)
    {
        if (poly.size() < 3) return 0.0;
        double polyArea = 0.0;
        Vector C = polygonCentroid(poly, polyArea);
        if (polyArea <= 0.0) return 0.0;

        double integral = 0.0;
        const size_t n = poly.size();
        for (size_t i = 0; i < n; ++i) {
            const Vector& A = poly[i];
            const Vector& B = poly[(i + 1) % n];
            integral += triGauss3Integral(C, A, B, segStart, segEnd);
        }
        return integral / polyArea;
    }

    inline bool pointOnSegment2D(const Vector& P, const Vector& A, const Vector& B, double eps = 1e-12)
    {
        Vector AP = P - A, AB = B - A;
        double cross = std::fabs(AP.m_x * AB.m_y - AP.m_y * AB.m_x);
        if (cross > eps) return false;
        double dot = AP.m_x * AB.m_x + AP.m_y * AB.m_y;
        if (dot < -eps) return false;
        double ab2 = AB.m_x * AB.m_x + AB.m_y * AB.m_y;
        if (dot - ab2 > eps) return false;
        return true;
    }

    // 2D polygon point-in test (odd-even rule), including boundary.
    inline bool pointInPolygon2D(
        const Vector& P,
        const std::vector<int>& polyNodeIDs,
        const std::unordered_map<int, Node>& nodes,
        double eps = 1e-12)
    {
        const int n = (int)polyNodeIDs.size();
        if (n < 3) return false;

        for (int i = 0; i < n; ++i) {
            const Vector& A = nodes.at(polyNodeIDs[i]).coord;
            const Vector& B = nodes.at(polyNodeIDs[(i + 1) % n]).coord;
            if (pointOnSegment2D(P, A, B, eps)) return true;
        }

        bool inside = false;
        for (int i = 0, j = n - 1; i < n; j = i++) {
            const Vector& Pi = nodes.at(polyNodeIDs[i]).coord;
            const Vector& Pj = nodes.at(polyNodeIDs[j]).coord;
            bool intersect = ((Pi.m_y > P.m_y) != (Pj.m_y > P.m_y));
            if (intersect) {
                double x_cross = Pj.m_x + (Pi.m_x - Pj.m_x)
                    * ((P.m_y - Pj.m_y) / (Pi.m_y - Pj.m_y + 1e-30));
                if (x_cross > P.m_x - eps) inside = !inside;
            }
        }
        return inside;
    }

 
    inline bool pointToSegmentDistance(const Vector& p, const Vector& s, const Vector& e)
    {
        Vector se = e - s;
        double segLenSq = se.m_x * se.m_x + se.m_y * se.m_y;
        if (segLenSq < 1e-12) return (p - s).Mag();
        double t = ((p - s) * se) / segLenSq;
        t = max(0.0, std::min(1.0, t));
        Vector projection = s + se * t;
        return (p - projection).Mag();
    }

    inline bool pointInTriangle(const Vector& p, const Vector& a, const Vector& b, const Vector& c)
    {
        Vector v0 = c - a, v1 = b - a, v2 = p - a;
        double dot00 = v0 * v0, dot01 = v0 * v1, dot02 = v0 * v2;
        double dot11 = v1 * v1, dot12 = v1 * v2;
        double invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
        double u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        double v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return (u > 1e-6) && (v > 1e-6) && ((u + v) < 1 - 1e-6);
    }
} // namespace FractureGeom


```


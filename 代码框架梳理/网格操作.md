好的，根据您的要求，我为您编写了 **“阶段一：构建网格棱及 Face-Edge 拓扑关系”** 的完整代码。

这段代码完全遵循您现有的代码风格（C++17），并实现了论文中 Algorithm 2 所需的基础数据结构。

---

### Step 1: 修改 `Mesh.h`

请将以下代码添加到 `Mesh.h` 中。

**操作指南**：
1.  找到 `class Face` 的定义，在其**上方**添加 `GridEdge` 结构体。
2.  找到 `class Mesh` 的 `public` 区域，添加成员变量和函数声明。

```cpp
// [Mesh.h] 
// ... Includes ...

// ==========================================
// [新增] 1. 定义 GridEdge 结构体
// ==========================================
struct GridEdge 
{
    int id;                     // 棱的全局编号 (从1开始)
    int node1;                  // 端点1 ID (保证 node1 < node2)
    int node2;                  // 端点2 ID
    double length;              // 棱长
    std::vector<int> faceIDs;   // 【核心】共享这条棱的所有 Face ID

    // 构造函数：自动排序节点ID，确保唯一性
    GridEdge(int _id, int n1, int n2) : id(_id), length(0.0) 
    {
        if (n1 < n2) {
            node1 = n1; node2 = n2;
        } else {
            node1 = n2; node2 = n1;
        }
    }
};

// ... existing class Node ...
// ... existing class Face ...

class Mesh 
{
public:
    // ... 原有的构造函数和成员 ...

    // ==========================================
    // [新增] 2. Mesh 类新增成员
    // ==========================================
    
    // 存储所有的网格棱
    std::vector<GridEdge> edges_;

    // 辅助映射：(小节点ID, 大节点ID) -> edges_中的索引(int)
    // 用于构建时快速查找某条边是否已存在，复杂度 O(log E)
    std::map<std::pair<int, int>, int> nodePairToEdgeIndex_;

    // [核心函数] 构建网格棱及其拓扑关系
    void BuildGridTopology();

    // ... 原有的函数声明 ...
};
```

---

### Step 2: 实现 `Mesh.cpp` 中的 `BuildGridTopology`

请将以下函数实现添加到 `Mesh.cpp` 的末尾。

**逻辑说明**：
*   该函数遍历所有 Face 的边缘。
*   利用 `std::pair<int, int>` 作为 Key 来识别同一条边（无论 Face 的节点顺序是顺时针还是逆时针，(u,v) 和 (v,u) 都会被标准化为 min-max）。
*   计算 `length` 时使用了您现有的 `nodesMap_`。

```cpp
// [Mesh.cpp]

// ==========================================
// [新增] 实现 BuildGridTopology
// ==========================================
void Mesh::BuildGridTopology()
{
    std::cout << "------------------------------------------------\n";
    std::cout << "[Topology] Start building Grid Edges & Face-Edge Topology...\n";

    // 1. 清理旧数据
    edges_.clear();
    nodePairToEdgeIndex_.clear();
    // 预留空间以减少内存重分配 (估算：边数约为面数的1.5-2倍)
    edges_.reserve(faces_.size() * 2); 

    int nextEdgeID = 1; // 棱 ID 从 1 开始

    // 2. 遍历所有面
    for (const auto& face : faces_)
    {
        const auto& fNodes = face.FaceNodeIDs;
        size_t n = fNodes.size();

        // 遍历面上的每一条边：(0,1), (1,2), ..., (n-1, 0)
        for (size_t i = 0; i < n; ++i)
        {
            int u = fNodes[i];
            int v = fNodes[(i + 1) % n]; // 闭合回到起点

            // 构造查找键值：始终保持 (min, max) 顺序
            int n1 = std::min(u, v);
            int n2 = std::max(u, v);
            std::pair<int, int> edgeKey = {n1, n2};

            // 3. 查找该棱是否已存在
            auto it = nodePairToEdgeIndex_.find(edgeKey);

            if (it == nodePairToEdgeIndex_.end())
            {
                // ---- Case A: 新棱 (第一次遇到) ----
                
                // 构造新 Edge
                GridEdge newEdge(nextEdgeID, n1, n2);

                // 计算长度 (需要访问节点坐标)
                if (nodesMap_.count(n1) && nodesMap_.count(n2)) {
                    const Vector& p1 = nodesMap_.at(n1).coord;
                    const Vector& p2 = nodesMap_.at(n2).coord;
                    newEdge.length = (p1 - p2).Mag();
                } else {
                    std::cerr << "[Error] Node ID not found in nodesMap_ during edge build.\n";
                }

                // 记录当前 Face ID
                newEdge.faceIDs.push_back(face.id);

                // 存入容器
                edges_.push_back(newEdge);

                // 记录映射关系 (Index = size - 1)
                nodePairToEdgeIndex_[edgeKey] = static_cast<int>(edges_.size() - 1);

                nextEdgeID++;
            }
            else
            {
                // ---- Case B: 已存在的棱 (邻居面共享) ----
                int edgeIndex = it->second;
                
                // 将当前 Face ID 追加到该 Edge 的邻居列表中
                edges_[edgeIndex].faceIDs.push_back(face.id);
            }
        }
    }

    std::cout << "[Topology] Build complete.\n";
    std::cout << "  - Total Faces processed: " << faces_.size() << "\n";
    std::cout << "  - Total Unique Edges generated: " << edges_.size() << "\n";
    std::cout << "------------------------------------------------\n";
}
```

---

### Step 3: 集成到 `MeshManager.cpp`

在网格生成流程中调用该函数。

**操作指南**：
修改 `MeshManager::BuildSolidMatrixGrid` 函数，在调用 `ClassifySolidMatrixCells` 之前插入构建拓扑的代码。

```cpp
// [MeshManager.cpp]

void MeshManager::BuildSolidMatrixGrid(NormalVectorCorrectionMethod corr) 
{
    // 1. 生成基础网格 (Nodes, Faces, Cells)
    mesh_.BuildMesh(lx_, ly_, lz_, nx_, ny_, nz_, usePrism_, useQuadBase_);

    // ==========================================
    // [新增] 2. 构建网格拓扑 (Edges & Connectivity)
    // 这是实现论文 Algorithm 2 的必要前提
    // ==========================================
    mesh_.BuildGridTopology(); 

    // 3. 剩下的原有流程
    mesh_.ClassifySolidMatrixCells();       
    bcGroups_ = BoundaryFaceClassify::ClassifyBoundaryFaces(mesh_, lx_, ly_, lz_, 1e-9);

    // ... (后续自检代码) ...
    mesh_.ComputeSolidMatrixMeshFaceGeometricInfor(corr);
}
```

---

### Step 4: 验证与自检 (Verification)

请将以下代码添加到 `Mesh::printMeshInfo` 函数的末尾，用于验证拓扑关系的正确性。

**验证逻辑**：
1.  **欧拉示性数检查**：对于简单的 3D 凸区域划分，Euler 公式 $V - E + F - C = 1$（忽略边界条件的大致估算）。这可以帮助判断棱的数量级是否正常。
2.  **详细抽查**：打印前几条棱，观察 `faceIDs`。内部棱应该有 2 个以上 Face ID，边界棱通常只有 1 个 Face ID（或者是边界面的 Edge）。

```cpp
// [Mesh.cpp] - inside void Mesh::printMeshInfo()

    // ... 原有的 Face 信息打印 ...

    // ==========================================
    // [新增] 验证棱 (Edge) 信息
    // ==========================================
    std::cout << "\n―― 拓扑验证 (Topology Check) ――" << endl;
    std::cout << "总棱数 (Edges): " << edges_.size() << endl;

    // 1. 简单的欧拉公式校验 (仅供参考)
    // V - E + F = 2 (对于单个凸多面体) 
    // V - E + F - C = 1 (对于多面体堆叠体，忽略孔洞)
    long long V = nodes_.size();
    long long E = edges_.size();
    long long F = faces_.size();
    long long C = cells_.size();
    long long euler = V - E + F - C;
    
    std::cout << "Euler Check (V - E + F - C): " << euler 
              << " (Expect ~1 for simple connected 3D mesh)" << endl;

    // 2. 打印前 5 条棱的拓扑信息
    std::cout << "Top 5 Edges Connectivity:" << endl;
    int printCount = 0;
    for (const auto& edge : edges_)
    {
        if (printCount++ >= 5) break;

        std::cout << "  Edge " << edge.id 
                  << " (" << edge.node1 << "-" << edge.node2 << ")"
                  << " Length=" << edge.length
                  << " | Shared by " << edge.faceIDs.size() << " Faces: [ ";
        
        for (int fid : edge.faceIDs) {
            std::cout << fid << " ";
        }
        std::cout << "]" << endl;
    }

    // 3. 统计边界棱 (只被1个面共用的棱)
    int boundaryEdges = 0;
    for (const auto& edge : edges_) {
        if (edge.faceIDs.size() == 1) boundaryEdges++;
    }
    std::cout << "边界棱数量 (Edges with 1 face): " << boundaryEdges << endl;
```

---

### 🚀 执行后续操作

1.  将上述代码复制粘贴到您的工程中。
2.  编译并运行。
3.  **关键检查点**：
    *   如果生成的是 **1个六面体单元**：应该看到 Edges = 12。
    *   如果生成的是 **2个相邻六面体**：Edges = 20 (12+12-4)。
    *   如果 `printMeshInfo` 中显示的 `Shared by Faces` 出现了 `[ 1 2 ]` 这种包含两个 ID 的情况，说明拓扑构建**成功**。这正是论文中 Algorithm 2 "Active Edge List" 传播所需的路径。





==============Prompt
这是一个为您准备的**完整的 Prompt（提示词）**。您可以直接将这段话发送给 ChatGPT 或 Claude，它会为您生成精准、风格统一且包含验证逻辑的代码。

---

### 复制以下内容作为 Prompt 发送：

**【背景与目标】**
我正在开发一个基于 Gmsh 的 3D 非结构化网格嵌入式离散裂缝模型（EDFM）模拟器。目前的进度是可以生成 Node、Face 和 Cell。
现在的任务是复现论文 *"An efficient and robust fracture-grid... intersection detection method"* 中的核心算法。为了实现论文中的 **Algorithm 2 (Grid-edge-fracture-face intersection)**，我需要从现有的“基于面”的数据结构升级为“基于棱（Edge）”的拓扑结构。

**【当前代码上下文】**
*   **Mesh.h**: 包含 `Node`, `Face`, `Cell` 类定义。
*   **Mesh.cpp**: 包含 `BuildMesh` 函数，已经生成了 `nodes_`, `faces_`, `cells_`。
*   **MeshManager.cpp**: 管理网格生成的流程。

**【任务要求】**
请作为一名资深的 C++ 科学计算程序员，指导我完成 **“阶段一：构建网格棱及 Face-Edge 拓扑关系”** 的代码编写。请分步生成以下代码，保持与我现有代码风格一致（C++17标准）：

**Step 1: 修改 `Mesh.h`**
*   定义 `GridEdge` 结构体。
    *   成员包括：`id` (int), `node1`, `node2` (int, 确保 node1 < node2), `length` (double)。
    *   **核心成员**：`std::vector<int> faceIDs`，用于存储共享这条棱的所有 Face 的 ID（这是论文算法的核心）。
*   在 `Mesh` 类中添加：
    *   `std::vector<GridEdge> edges_` 用于存储所有棱。
    *   `std::map<std::pair<int, int>, int> nodePairToEdgeIndex_` 用于在构建时快速去重查找。
    *   声明函数 `void BuildGridTopology();`。

**Step 2: 实现 `Mesh.cpp` 中的 `BuildGridTopology`**
*   请编写该函数的具体实现。
*   **逻辑**：遍历 `faces_` -> 遍历面的节点对 -> 构造 Edge Key (min, max) -> 查表 `nodePairToEdgeIndex_`。
    *   如果 Edge 不存在：创建新 `GridEdge`，计算长度，将当前 Face ID 加入其列表，存入 `edges_` 和 Map。
    *   如果 Edge 已存在：直接将当前 Face ID 追加到该 Edge 的 `faceIDs` 列表中。

**Step 3: 集成到 `MeshManager.cpp`**
*   展示如何在 `BuildSolidMatrixGrid` 函数中调用该方法。

**Step 4: 验证与自检 (Verification)**
*   请提供一段验证代码（可以放在 `Mesh::printMeshInfo` 中），用于打印：
    *   生成的总棱数（Total Edges）。
    *   进行简单的欧拉公式校验（Euler Characteristic check）：对于简单凸多面体堆叠，$V - E + F \approx \text{CellNum} + 1$（仅做参考）。
    *   打印前 5 条 Edge 的信息（连接的节点 ID 和共享的 Face ID 列表），以人工检查拓扑关系的正确性。

请确保代码健壮性，处理好 3D 非结构化网格中一条棱可能被多个面（2个或更多）共享的情况。

---

### 💡 如何使用这个 Prompt？

1.  **直接发送**：将上面的内容完整复制发送给我（或者新的对话窗口）。
2.  **获取代码**：我会按照这个要求，输出精确的 C++ 代码块。
3.  **粘贴/运行**：你只需要将生成的代码块分别粘贴到 `Mesh.h` 和 `Mesh.cpp` 的对应位置。
4.  **验证**：运行程序，查看控制台输出的“Edge”数量是否合理，从而确认拓扑关系构建成功。
void Face::computeFaceVectors(const Vector& Cp, const Vector& Cn, NormalVectorCorrectionMethod method)
{
    // 1) 计算从 owner 到 neighbor 的向量 d
    ownerToNeighbor = Cn - Cp;
    double d_norm = ownerToNeighbor.Mag();
    if (d_norm < 1e-12) 
    {
        // 重心重合或太近，直接置零
        vectorE = Vector(0.0, 0.0, 0.0);
        vectorT = Vector(0.0, 0.0, 0.0);
        return;
    }
    Vector ej = ownerToNeighbor / d_norm;  // 单位方向向量
    //cout << "Face " << id << " 的单位方向向量 e_j: ("
    //    << ej.m_x << ", " << ej.m_y << ", " << ej.m_z << ")  "
    //    << endl;

    // 2) 构造面积矢量 A_j = normal * length
    Vector Aj = normal * length;
    double Aj_dot_ej = Aj * ej;  // 点积
    
    if ((Aj * ej) < 0)
    {
		Aj = -Aj; //		// 确保法向量与单位向量同向
        Aj_dot_ej = -Aj_dot_ej;
    }
    // —— 关键容错：近正交（Aj·ej≈0）时的保护 —— 
    const double eps = 1e-14;   // 可按你的坐标尺度调整
    if (Aj_dot_ej < eps) Aj_dot_ej = eps;

   //cout << "Face " << id << " 的面积矢量 A_j: (" 
   //      << Aj.m_x << ", " << Aj.m_y << ", " << Aj.m_z << ") 长度: " 
   //      << length << endl;


    // 3) 依据不同算法分解 A_j = E_j + T_j
    switch (method) 
    {
    case NormalVectorCorrectionMethod::MinimumCorrection:
        // E_j = (A_j·e_j) e_j
        vectorE = ej * Aj_dot_ej;
        //cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;

        break;

    case NormalVectorCorrectionMethod::OrthogonalCorrection:
        // E_j = |A_j| e_j, 其中 |A_j| = length (normal 已单位化)
        vectorE = ej * length;
       // cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;
        break;

    case NormalVectorCorrectionMethod::OverRelaxed:
    {
        // E_j = |A_j|^2 / (A_j·e_j) * e_j
        double Aj_norm = length;
        double factor = (Aj_norm * Aj_norm) / Aj_dot_ej;
        vectorE = ej * factor;
        //cout << "Face :" << id << "的E矢量:(" << vectorE.m_x << ", " << vectorE.m_y << ", " << vectorE.m_z << ")" << endl;
        break;
    }
    }

    // 4) 非正交分量
    vectorT = Aj - vectorE;
   // cout << "Face :" << id << "的T矢量:(" << vectorT.m_x << ", " << vectorT.m_y << ", " << vectorT.m_z << ")" << endl;

    //5） 正交插值权重gamma 投影到 e_j（0..1 之间）
    double D = ownerToNeighbor * ej;     // 应等于 d_norm
    //cout << "Face " << id << "D: " << D << endl;
    //cout << "Face " << id << "d_norm: " << d_norm << endl;
    double s = (midpoint - Cp) * ej;     // owner 到 面心 在 e_j 上的投影
    double gamma = (std::abs(D) > 1e-14) ? (s / D) : 0.5; // 容错
    if (gamma < 0.0) gamma = 0.0;
    if (gamma > 1.0) gamma = 1.0;
    f_linearInterpolationCoef = gamma;

}


/**
 * @brief 处理边界面时的分解 A_j = E_j + T_j
 *
 * @param Cp      ownerCell 的重心坐标
 * @param method  选择三种校正策略之一（目前未使用）
 * 边界面没邻居中心坐标 Cn，但做 E/T 分解只需面法向和模长即可
 * 用 rPF 保证 normal 始终朝外，避免节点序反向导致的“内法向”。
 */
void Face::computeFaceVectorsBoundary(const Vector& Cp,
    NormalVectorCorrectionMethod /*method*/)
{
    // 1) 依据 owner中心 -> 面心 的向量与当前 normal 的夹角，修正法向指向外侧
    Vector rPF = midpoint - Cp;
    double sgn = (normal * rPF) >= 0.0 ? 1.0 : -1.0;

    // ↓↓↓ 把外指法向写回，并确保为单位向量 ↓↓↓
    normal = normal * sgn;
    double nmag2 = normal.m_x * normal.m_x + normal.m_y * normal.m_y + normal.m_z * normal.m_z;
    if (nmag2 > 0.0) {
        double invn = 1.0 / std::sqrt(nmag2);
        normal = normal * invn;
    }

    // 2) 面积矢量 A = |A| * n_hat；2D 情况下 |A| = 边长 length（3D 为面积）
    Vector Aj = normal * length;

    // 3) 边界面分解
    vectorE = Aj;
    vectorT = Vector(0.0, 0.0, 0.0);

    // 4) owner→外部 的方向（与 normal 一致）
    ownerToNeighbor = rPF;
    f_linearInterpolationCoef = 1.0;
}
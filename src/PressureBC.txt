#pragma once
#include <unordered_map>
#include <vector>
#include <string>
#include <iostream>  
#include "MeshManager.h"
#include "BoundaryFaceClassify.h"

namespace PressureBC {

	struct BoundaryCoefficient { double a{ 0 }, b{ 0 }, c{ 0 }; }; //   由边界面上的值获得所在网格单元的值的统一表达式：a·p + b·∂p/∂n = c 这里先将a b c系数赋值在边界面上，后续计算系数需要
	using FaceID = int; //便于理解

	//p_w注册
	class Registry
	{
	public:

		//设置第三类边界条件
		void addBoundaryCoefficientValue(const std::vector<FaceID>& faces, BoundaryCoefficient r)
		{
		     for (int fid : faces) map_[fid] = r;
		}

		//设置第一类边界条件 Dirichlet p=pb
		void addDirichlet(const std::vector<FaceID>& faces, double p_b)
		{
			addBoundaryCoefficientValue(faces, BoundaryCoefficient{ 1.0, 0.0, p_b });
		}


		//设置第二类边界条件 ∂p/∂n = g_n（法向梯度）
		void addNeumannGrad(const std::vector<FaceID>& faces, double g_n)
		{
			addBoundaryCoefficientValue(faces, BoundaryCoefficient{ 0.0, 1.0, g_n });
		}

		//查询
		const BoundaryCoefficient* find(int faceId) const {
			auto it = map_.find(faceId);
			return (it == map_.end() ? nullptr : &it->second);
		}

		//统计 调试

		size_t size() const { return map_.size(); }
		void printInformationofBoundarySetting(MeshManager& mgr) 
		{
			size_t hit = 0;
			for (auto const& f : mgr.mesh().getFaces())
			{
				if (!f.isBoundary()) continue;

				const auto it = map_.find(f.id);
				if (it != map_.end())
				{
					++hit;
					const auto& r = it->second;
					std::cout << "face #" << f.id
						<< "  a=" << r.a
						<< "  b=" << r.b
						<< "  c=" << r.c
						<< std::endl;
				}
			}
				
			std::cout << "[BC:p_w] total faces set = " << hit << "\n";
			

		}

	private:

		std::unordered_map<FaceID, BoundaryCoefficient> map_;


	};

	// 2D 便捷配置（Lz=0 情况）
	inline void setBoxBCs2D(Registry& reg, const BoundaryFaceClassify::FaceGroups& G, BoundaryCoefficient left, BoundaryCoefficient right, BoundaryCoefficient down, BoundaryCoefficient up)
	{
		reg.addBoundaryCoefficientValue(G.x0, left);
		reg.addBoundaryCoefficientValue(G.xL, right);
		reg.addBoundaryCoefficientValue(G.y0, down);
		reg.addBoundaryCoefficientValue(G.yL, up);
	}

	inline void setBoxBCs3D(Registry& reg, const BoundaryFaceClassify::FaceGroups& G, BoundaryCoefficient left, BoundaryCoefficient right, BoundaryCoefficient down, BoundaryCoefficient up, BoundaryCoefficient front, BoundaryCoefficient back)
	{
		reg.addBoundaryCoefficientValue(G.x0, left);
		reg.addBoundaryCoefficientValue(G.xL, right);
		reg.addBoundaryCoefficientValue(G.y0, down);
		reg.addBoundaryCoefficientValue(G.yL, up);
		reg.addBoundaryCoefficientValue(G.z0, front);
		reg.addBoundaryCoefficientValue(G.zL, back);

	}

}
